<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KlangReise ‚Äì Entdecke die Magie der Musik</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@300;400;500;600&family=Nunito:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-gradient-start: #1a1a2e;
            --bg-gradient-end: #16213e;
            --accent-warm: #ff6b6b;
            --accent-gold: #ffd93d;
            --accent-teal: #6bcb77;
            --accent-blue: #4d96ff;
            --accent-purple: #9b5de5;
            --text-light: #f8f8f8;
            --text-muted: #a0a0b0;
            --card-bg: rgba(255, 255, 255, 0.08);
            --card-border: rgba(255, 255, 255, 0.12);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Nunito', sans-serif;
            background: linear-gradient(135deg, var(--bg-gradient-start) 0%, var(--bg-gradient-end) 100%);
            min-height: 100vh;
            color: var(--text-light);
            overflow-x: hidden;
        }

        body.island-mode {
            /* Calmer frame around the island map so it reads clearly. */
            background: linear-gradient(135deg, #0b1020 0%, #0a1428 100%);
        }

        /* Animated background particles */
        .bg-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 0;
        }

        body.island-mode .bg-particles {
            display: none;
        }

        .particle {
            position: absolute;
            border-radius: 50%;
            opacity: 0.3;
            animation: float 20s infinite ease-in-out;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-100px) rotate(180deg); }
        }

        /* Main container */
        .app-container {
            position: relative;
            z-index: 1;
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }

        /* Header */
        .header {
            text-align: center;
            margin-bottom: 3rem;
            animation: fadeInDown 0.8s ease-out;
        }

        @keyframes fadeInDown {
            from { opacity: 0; transform: translateY(-30px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .logo {
            font-family: 'Fredoka', sans-serif;
            font-size: 3.5rem;
            font-weight: 600;
            background: linear-gradient(135deg, var(--accent-gold) 0%, var(--accent-warm) 50%, var(--accent-purple) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 0.5rem;
            letter-spacing: -1px;
        }

        .tagline {
            font-size: 1.2rem;
            color: var(--text-muted);
            font-weight: 400;
        }

        /* Navigation Tabs */
        .nav-tabs {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .nav-tab {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 2rem;
            padding: 0.8rem 1.5rem;
            font-family: 'Nunito', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .nav-tab:hover {
            background: rgba(255, 255, 255, 0.12);
            color: var(--text-light);
        }

        .nav-tab.active {
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            color: white;
            border-color: transparent;
            box-shadow: 0 4px 20px rgba(155, 93, 229, 0.4);
        }

        /* Screens */
        .screen {
            display: none;
            animation: fadeIn 0.5s ease-out;
        }

        .screen.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Welcome Screen */
        .welcome-container {
            text-align: center;
            padding: 3rem;
        }

        .welcome-illustration {
            width: 200px;
            height: 200px;
            margin: 0 auto 2rem;
            background: linear-gradient(135deg, var(--accent-purple) 0%, var(--accent-blue) 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 5rem;
            animation: pulse 3s infinite ease-in-out;
            box-shadow: 0 0 60px rgba(155, 93, 229, 0.5);
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 60px rgba(155, 93, 229, 0.5); }
            50% { transform: scale(1.05); box-shadow: 0 0 80px rgba(155, 93, 229, 0.7); }
        }

        .welcome-text {
            font-size: 1.4rem;
            line-height: 1.8;
            max-width: 600px;
            margin: 0 auto 2rem;
            color: var(--text-light);
        }

        .start-btn {
            background: linear-gradient(135deg, var(--accent-gold) 0%, var(--accent-warm) 100%);
            border: none;
            border-radius: 3rem;
            padding: 1.2rem 3rem;
            font-family: 'Fredoka', sans-serif;
            font-size: 1.4rem;
            font-weight: 500;
            color: #1a1a2e;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 30px rgba(255, 107, 107, 0.4);
        }

        .start-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 40px rgba(255, 107, 107, 0.6);
        }

        /* Play Screen */
        .play-container {
            display: grid;
            grid-template-columns: 1fr;
            gap: 2rem;
        }

        /* Visualization Canvas */
        .visualization-area {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 2rem;
            padding: 2rem;
            min-height: 300px;
            position: relative;
            overflow: hidden;
        }

        .visualization-canvas {
            width: 100%;
            height: 250px;
            border-radius: 1rem;
        }

        .mood-label {
            position: absolute;
            top: 1rem;
            left: 1.5rem;
            font-family: 'Fredoka', sans-serif;
            font-size: 1.2rem;
            color: var(--accent-gold);
        }

        /* Controls */
        .controls-area {
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
        }

        .control-btn {
            background: var(--card-bg);
            border: 2px solid var(--card-border);
            border-radius: 50%;
            width: 70px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.8rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            transform: scale(1.1);
            border-color: var(--accent-purple);
        }

        .control-btn.recording {
            background: var(--accent-warm);
            border-color: var(--accent-warm);
            animation: recordPulse 1s infinite;
        }

        @keyframes recordPulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(255, 107, 107, 0.4); }
            50% { box-shadow: 0 0 0 15px rgba(255, 107, 107, 0); }
        }

        .control-btn.listening {
            background: var(--accent-teal);
            border-color: var(--accent-teal);
        }

        /* Detected Notes Display */
        .notes-display {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 1.5rem;
            padding: 1.5rem;
            text-align: center;
        }

        .notes-label {
            font-size: 0.9rem;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }

        .detected-note {
            font-family: 'Fredoka', sans-serif;
            font-size: 3rem;
            font-weight: 600;
            color: var(--accent-gold);
            min-height: 4rem;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .note-history {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-top: 1rem;
            flex-wrap: wrap;
        }

        .note-bubble {
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            border-radius: 1rem;
            padding: 0.5rem 1rem;
            font-family: 'Fredoka', sans-serif;
            font-size: 1rem;
            animation: popIn 0.3s ease-out;
        }

        @keyframes popIn {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        /* Klangwelten (Sound Worlds) */
        .worlds-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
        }

        .world-card {
            background: var(--card-bg);
            border: 2px solid var(--card-border);
            border-radius: 1.5rem;
            padding: 2rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .world-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .world-card:hover {
            transform: translateY(-5px);
            border-color: var(--accent-purple);
        }

        .world-card:hover::before {
            opacity: 0.1;
        }

        .world-card.mysterious { --world-color: #9b5de5; }
        .world-card.mysterious::before { background: var(--world-color); }
        .world-card.joyful { --world-color: #ffd93d; }
        .world-card.joyful::before { background: var(--world-color); }
        .world-card.dreamy { --world-color: #4d96ff; }
        .world-card.dreamy::before { background: var(--world-color); }
        .world-card.exciting { --world-color: #ff6b6b; }
        .world-card.exciting::before { background: var(--world-color); }
        .world-card.calm { --world-color: #6bcb77; }
        .world-card.calm::before { background: var(--world-color); }

        .world-card.active {
            border-color: var(--world-color);
            box-shadow: 0 0 30px rgba(155, 93, 229, 0.3);
        }

        .world-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .world-name {
            font-family: 'Fredoka', sans-serif;
            font-size: 1.4rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
        }

        .world-desc {
            font-size: 0.95rem;
            color: var(--text-muted);
            line-height: 1.5;
        }

        /* Klangtagebuch (Sound Diary) */
        .diary-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .diary-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .diary-title {
            font-family: 'Fredoka', sans-serif;
            font-size: 2rem;
            font-weight: 500;
        }

        .diary-stats {
            display: flex;
            gap: 2rem;
        }

        .stat-item {
            text-align: center;
        }

        .stat-value {
            font-family: 'Fredoka', sans-serif;
            font-size: 2rem;
            font-weight: 600;
            color: var(--accent-gold);
        }

        .stat-label {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .diary-entries {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .diary-entry {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 1.5rem;
            padding: 1.5rem;
            display: flex;
            align-items: center;
            gap: 1.5rem;
            transition: all 0.3s ease;
        }

        .diary-entry:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .entry-emoji {
            font-size: 2.5rem;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--card-bg);
            border-radius: 1rem;
        }

        .entry-info {
            flex: 1;
        }

        .entry-date {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-bottom: 0.3rem;
        }

        .entry-title {
            font-family: 'Fredoka', sans-serif;
            font-size: 1.2rem;
            font-weight: 500;
        }

        .entry-duration {
            font-size: 0.85rem;
            color: var(--accent-teal);
            margin-top: 0.3rem;
        }

        .entry-play {
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            border: none;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .entry-play:hover {
            transform: scale(1.1);
        }

        .empty-diary {
            text-align: center;
            padding: 4rem 2rem;
            color: var(--text-muted);
        }

        .empty-diary-icon {
            font-size: 4rem;
            margin-bottom: 1rem;
            opacity: 0.5;
        }

        /* Garden Progress */
        .garden-container {
            text-align: center;
            padding: 2rem;
        }

        .garden-title {
            font-family: 'Fredoka', sans-serif;
            font-size: 2rem;
            font-weight: 500;
            margin-bottom: 1rem;
        }

        .garden-subtitle {
            color: var(--text-muted);
            margin-bottom: 2rem;
        }

        .garden-visual {
            background: linear-gradient(180deg, #1a1a2e 0%, #2d4a3e 100%);
            border-radius: 2rem;
            padding: 3rem;
            min-height: 300px;
            position: relative;
            overflow: hidden;
        }

        .garden-ground {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: linear-gradient(180deg, #3d5a4a 0%, #2d4a3e 100%);
            border-radius: 0 0 2rem 2rem;
        }

        .plant {
            position: absolute;
            bottom: 50px;
            font-size: 3rem;
            animation: sway 3s infinite ease-in-out;
        }

        @keyframes sway {
            0%, 100% { transform: rotate(-5deg); }
            50% { transform: rotate(5deg); }
        }

        .garden-message {
            position: relative;
            z-index: 1;
            font-family: 'Fredoka', sans-serif;
            font-size: 1.2rem;
            color: var(--accent-gold);
        }

        /* Prompt Cards */
        .prompt-card {
            background: linear-gradient(135deg, rgba(155, 93, 229, 0.2), rgba(77, 150, 255, 0.2));
            border: 1px solid var(--accent-purple);
            border-radius: 1.5rem;
            padding: 2rem;
            text-align: center;
            margin-bottom: 2rem;
        }

        .prompt-label {
            font-size: 0.9rem;
            color: var(--accent-purple);
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .prompt-text {
            font-family: 'Fredoka', sans-serif;
            font-size: 1.6rem;
            font-weight: 500;
            line-height: 1.4;
        }

        .prompt-refresh {
            background: transparent;
            border: 1px solid var(--card-border);
            border-radius: 2rem;
            padding: 0.5rem 1.5rem;
            color: var(--text-muted);
            font-family: 'Nunito', sans-serif;
            cursor: pointer;
            margin-top: 1rem;
            transition: all 0.3s ease;
        }

        .prompt-refresh:hover {
            border-color: var(--accent-purple);
            color: var(--text-light);
        }

        /* Microphone Permission Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: var(--bg-gradient-start);
            border: 1px solid var(--card-border);
            border-radius: 2rem;
            padding: 3rem;
            max-width: 500px;
            text-align: center;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .modal-overlay.active .modal-content {
            transform: scale(1);
        }

        .modal-icon {
            font-size: 4rem;
            margin-bottom: 1.5rem;
        }

        .modal-title {
            font-family: 'Fredoka', sans-serif;
            font-size: 1.8rem;
            margin-bottom: 1rem;
        }

        .modal-text {
            color: var(--text-muted);
            margin-bottom: 2rem;
            line-height: 1.6;
        }

        .modal-btn {
            background: linear-gradient(135deg, var(--accent-teal), var(--accent-blue));
            border: none;
            border-radius: 2rem;
            padding: 1rem 2.5rem;
            font-family: 'Fredoka', sans-serif;
            font-size: 1.1rem;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .modal-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 20px rgba(107, 203, 119, 0.4);
        }

        /* Island Navigation */
        .island-screen {
            padding: 2rem 0 3rem;
        }

        .island-map {
            position: relative;
            isolation: isolate;
            min-height: 520px;
            border-radius: 2.5rem;
            padding: 2.5rem;
            background: radial-gradient(circle at 20% 20%, rgba(255, 217, 61, 0.25), rgba(26, 26, 46, 0.95)),
                        radial-gradient(circle at 80% 30%, rgba(77, 150, 255, 0.18), transparent 55%),
                        linear-gradient(160deg, rgba(22, 33, 62, 0.9), rgba(10, 12, 28, 0.98));
            border: 1px solid rgba(255, 255, 255, 0.08);
            overflow: hidden;
        }

        .island-video {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 0;
            opacity: 1;
            pointer-events: none;
        }

        .island-map::after {
            content: '';
            position: absolute;
            inset: 0;
            z-index: 1;
            pointer-events: none;
            background: radial-gradient(circle at 20% 20%, rgba(255, 217, 61, 0.12), rgba(0, 0, 0, 0.45)),
                        radial-gradient(circle at 80% 30%, rgba(77, 150, 255, 0.12), transparent 55%),
                        linear-gradient(160deg, rgba(22, 33, 62, 0.38), rgba(6, 8, 20, 0.6));
        }

        .island-map[data-theme="night"] {
            background: radial-gradient(circle at 20% 20%, rgba(77, 150, 255, 0.2), rgba(10, 12, 28, 0.98)),
                        radial-gradient(circle at 80% 20%, rgba(155, 93, 229, 0.18), transparent 55%),
                        linear-gradient(160deg, rgba(10, 12, 28, 0.95), rgba(6, 8, 20, 0.98));
        }

        .island-map[data-theme="sunrise"] {
            background: radial-gradient(circle at 20% 20%, rgba(255, 217, 61, 0.4), rgba(26, 26, 46, 0.92)),
                        radial-gradient(circle at 80% 30%, rgba(255, 107, 107, 0.25), transparent 55%),
                        linear-gradient(160deg, rgba(22, 33, 62, 0.9), rgba(10, 12, 28, 0.95));
        }

        .island-map[data-theme="sunset"] {
            background: radial-gradient(circle at 20% 20%, rgba(255, 107, 107, 0.35), rgba(26, 26, 46, 0.95)),
                        radial-gradient(circle at 80% 30%, rgba(255, 217, 61, 0.2), transparent 55%),
                        linear-gradient(160deg, rgba(22, 33, 62, 0.9), rgba(10, 12, 28, 0.98));
        }

        .island-glow {
            position: absolute;
            inset: -40% -40% auto auto;
            width: 380px;
            height: 380px;
            background: radial-gradient(circle, rgba(255, 217, 61, 0.15), transparent 70%);
            opacity: 0.35;
            pointer-events: none;
            z-index: 2;
        }

        .island-title {
            font-family: 'Fredoka', sans-serif;
            font-size: 2rem;
            margin-bottom: 0.6rem;
        }

        .island-subtitle {
            color: var(--text-muted);
            margin-bottom: 1.5rem;
        }

        .island-landmark {
            position: absolute;
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 1.5rem;
            padding: 0.9rem 1.2rem;
            min-width: 150px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
            z-index: 3;
        }

        .island-landmark:hover {
            transform: translateY(-3px);
            border-color: rgba(255, 255, 255, 0.35);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.3);
        }

        .island-landmark.disabled {
            opacity: 0.45;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .landmark-icon {
            font-size: 2rem;
            margin-bottom: 0.2rem;
        }

        .landmark-label {
            font-family: 'Fredoka', sans-serif;
            font-size: 1rem;
        }

        .landmark-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-top: 0.4rem;
            font-size: 0.85rem;
            padding: 0.2rem 0.6rem;
            border-radius: 999px;
            background: rgba(0, 0, 0, 0.35);
            color: var(--text-light);
        }

        .island-garden {
            position: absolute;
            left: 50%;
            top: 52%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.16);
            border-radius: 2rem;
            padding: 1.2rem 1.4rem;
            text-align: center;
            min-width: 180px;
            z-index: 3;
        }

        .island-garden .landmark-icon {
            font-size: 2.4rem;
        }

        .compass-btn {
            position: fixed;
            right: 1.5rem;
            bottom: 1.5rem;
            width: 62px;
            height: 62px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.6rem;
            cursor: pointer;
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.25);
            transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;
            z-index: 20;
        }

        .compass-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 16px 30px rgba(0, 0, 0, 0.3);
        }

        .compass-btn.hidden {
            opacity: 0;
            pointer-events: none;
        }

        /* Module tabs (inside "Spielen") */
        .module-tabs {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin: 1.25rem 0 1.5rem;
            flex-wrap: wrap;
        }

        .module-tab {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid var(--card-border);
            border-radius: 2rem;
            padding: 0.6rem 1.1rem;
            font-family: 'Nunito', sans-serif;
            font-size: 0.95rem;
            font-weight: 700;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.25s ease;
        }

        .module-tab:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-light);
        }

        .module-tab.active {
            background: linear-gradient(135deg, var(--accent-teal), var(--accent-blue));
            color: white;
            border-color: transparent;
            box-shadow: 0 4px 18px rgba(77, 150, 255, 0.28);
        }

        .module-tab:disabled {
            opacity: 0.45;
            cursor: not-allowed;
        }

        .module-screen {
            display: none;
            animation: fadeIn 0.45s ease-out;
        }

        .module-screen.active {
            display: block;
        }

        /* Echo-Spiel */
        .echo-card {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 2rem;
            padding: 2rem;
            overflow: hidden;
            position: relative;
        }

        .echo-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .echo-title {
            font-family: 'Fredoka', sans-serif;
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .echo-subtitle {
            color: var(--text-muted);
            line-height: 1.5;
        }

        .echo-progress {
            display: flex;
            gap: 0.45rem;
            margin-top: 0.35rem;
            flex-shrink: 0;
        }

        .echo-dot {
            width: 12px;
            height: 12px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.16);
        }

        .echo-dot.filled {
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-warm));
            border-color: rgba(255, 255, 255, 0.18);
            box-shadow: 0 0 18px rgba(255, 217, 61, 0.25);
        }

        .echo-status {
            background: rgba(0, 0, 0, 0.18);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 1.2rem;
            padding: 1rem 1.2rem;
            color: var(--text-light);
            line-height: 1.6;
            margin: 1rem 0 1.2rem;
            min-height: 3.6rem;
        }

        .echo-controls {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 1.5rem;
        }

        .echo-btn {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 2rem;
            padding: 0.9rem 1.4rem;
            font-family: 'Fredoka', sans-serif;
            font-size: 1.05rem;
            font-weight: 500;
            color: var(--text-light);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        }

        .echo-btn:hover {
            transform: translateY(-1px);
            background: rgba(255, 255, 255, 0.12);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.22);
        }

        .echo-btn.primary {
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-warm));
            border-color: transparent;
            color: #1a1a2e;
            box-shadow: 0 8px 26px rgba(255, 107, 107, 0.25);
        }

        .echo-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .echo-piano-wrap {
            background: rgba(0, 0, 0, 0.16);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 1.5rem;
            padding: 1.25rem;
        }

        .echo-piano {
            position: relative;
            width: 100%;
            max-width: 820px;
            margin: 0 auto;
            height: 190px;
            user-select: none;
            touch-action: manipulation;
        }

        .echo-white-keys {
            position: absolute;
            inset: 0;
            display: flex;
            gap: 6px;
            padding: 6px;
        }

        .echo-key {
            border-radius: 14px;
            transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease;
        }

        .echo-key.white {
            flex: 1;
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid rgba(0, 0, 0, 0.22);
            box-shadow: 0 10px 26px rgba(0, 0, 0, 0.18);
        }

        .echo-key.black {
            position: absolute;
            top: 6px;
            height: 58%;
            background: rgba(15, 16, 28, 0.92);
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: 0 10px 24px rgba(0, 0, 0, 0.35);
            border-radius: 12px;
            z-index: 2;
        }

        .echo-key.playing {
            transform: translateY(-2px);
            box-shadow: 0 0 0 4px rgba(255, 217, 61, 0.28), 0 18px 38px rgba(0, 0, 0, 0.28);
        }

        .echo-key.playing.white {
            background: rgba(255, 217, 61, 0.95);
        }

        .echo-key.playing.black {
            background: rgba(255, 107, 107, 0.95);
        }

        .echo-key.heard {
            transform: translateY(-2px);
            box-shadow: 0 0 0 4px rgba(107, 203, 119, 0.26), 0 18px 38px rgba(0, 0, 0, 0.26);
        }

        .echo-key.heard.white {
            background: rgba(107, 203, 119, 0.92);
        }

        .echo-key.heard.black {
            background: rgba(107, 203, 119, 0.85);
        }

        .echo-key.target {
            box-shadow: 0 0 0 3px rgba(255, 217, 61, 0.22), 0 0 22px rgba(255, 217, 61, 0.25);
            animation: echoPulse 1.6s ease-in-out infinite;
        }

        .echo-key.flash {
            box-shadow: 0 0 0 4px rgba(255, 107, 107, 0.32), 0 0 28px rgba(255, 107, 107, 0.38);
        }

        @keyframes echoPulse {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        .echo-magnet {
            position: absolute;
            width: 16px;
            height: 16px;
            border-radius: 999px;
            background: radial-gradient(circle, rgba(107, 203, 119, 0.95), rgba(107, 203, 119, 0.2));
            box-shadow: 0 0 18px rgba(107, 203, 119, 0.45);
            opacity: 0;
            transform: translate(-9999px, -9999px);
            pointer-events: none;
            transition: transform 0.5s ease-out, opacity 0.3s ease-out;
            z-index: 5;
        }

        .echo-magnet.active {
            opacity: 1;
        }

        .echo-celebrate {
            position: absolute;
            inset: 0;
            pointer-events: none;
            opacity: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3rem;
            transform: scale(0.98);
        }

        .echo-celebrate.active {
            animation: echoCelebrate 1.1s ease-out;
        }

        @keyframes echoCelebrate {
            0% { opacity: 0; transform: scale(0.92); }
            12% { opacity: 1; transform: scale(1.02); }
            100% { opacity: 0; transform: scale(1.08); }
        }

        /* Impro-Spielplatz */
        .impro-card {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            border-radius: 2rem;
            padding: 2rem;
            position: relative;
            overflow: hidden;
        }

        .impro-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 1rem;
            margin-bottom: 1.2rem;
        }

        .impro-title {
            font-family: 'Fredoka', sans-serif;
            font-size: 1.8rem;
            font-weight: 600;
            margin-bottom: 0.2rem;
        }

        .impro-subtitle {
            color: var(--text-muted);
            line-height: 1.5;
        }

        .impro-worlds {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 0.8rem;
            margin-bottom: 1.2rem;
        }

        .impro-world {
            background: rgba(255, 255, 255, 0.06);
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 1.2rem;
            padding: 1rem 1.1rem;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        }

        .impro-world strong {
            font-family: 'Fredoka', sans-serif;
            font-size: 1.15rem;
            display: block;
            margin-bottom: 0.3rem;
        }

        .impro-world span {
            color: var(--text-muted);
            font-size: 0.95rem;
            line-height: 1.4;
        }

        .impro-world.sun { --impro-color: #ffd93d; }
        .impro-world.moon { --impro-color: #4d96ff; }
        .impro-world.adventure { --impro-color: #9b5de5; }

        .impro-world.active {
            border-color: var(--impro-color);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.25);
            transform: translateY(-2px);
        }

        .impro-status {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 1.2rem;
            padding: 1rem 1.2rem;
            min-height: 3.4rem;
            line-height: 1.6;
            margin-bottom: 1.4rem;
        }

        .impro-visual {
            position: relative;
            background: rgba(10, 12, 24, 0.35);
            border-radius: 1.6rem;
            border: 1px solid rgba(255, 255, 255, 0.08);
            min-height: 160px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 1.4rem;
            overflow: hidden;
        }

        .impro-aura {
            width: 120px;
            height: 120px;
            border-radius: 999px;
            background: radial-gradient(circle, rgba(255, 217, 61, 0.75), rgba(255, 217, 61, 0.1));
            box-shadow: 0 0 40px rgba(255, 217, 61, 0.35);
            opacity: 0.3;
            transform: scale(0.9);
            transition: transform 0.25s ease, opacity 0.25s ease, filter 0.25s ease;
        }

        .impro-visual.active .impro-aura {
            opacity: 1;
            transform: scale(1.05);
        }

        .impro-visual.contrast .impro-aura {
            background: radial-gradient(circle, rgba(255, 107, 255, 0.85), rgba(255, 107, 255, 0.1));
            box-shadow: 0 0 40px rgba(255, 107, 255, 0.4);
            filter: saturate(130%);
        }

        .impro-visual.soft .impro-aura {
            opacity: 0.15;
            transform: scale(0.85);
        }

        .impro-piano-wrap {
            background: rgba(0, 0, 0, 0.16);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 1.5rem;
            padding: 1.25rem;
        }

        .impro-piano {
            position: relative;
            width: 100%;
            max-width: 820px;
            margin: 0 auto;
            height: 190px;
            user-select: none;
            --impro-color: #ffd93d;
            --impro-glow: rgba(255, 217, 61, 0.18);
        }

        .impro-white-keys {
            position: absolute;
            inset: 0;
            display: flex;
            gap: 6px;
            padding: 6px;
        }

        .impro-key {
            border-radius: 14px;
            transition: transform 0.12s ease, box-shadow 0.12s ease, background 0.12s ease, opacity 0.12s ease;
            opacity: 0.5;
        }

        .impro-key.allowed {
            opacity: 1;
            box-shadow: 0 0 0 2px var(--impro-glow);
        }

        .impro-key.white {
            flex: 1;
            background: rgba(255, 255, 255, 0.85);
            border: 1px solid rgba(0, 0, 0, 0.2);
        }

        .impro-key.black {
            position: absolute;
            top: 6px;
            height: 58%;
            background: rgba(15, 16, 28, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 12px;
            z-index: 2;
            opacity: 0.4;
        }

        .impro-key.allowed.black {
            opacity: 0.9;
        }

        .impro-key.playing {
            transform: translateY(-2px);
            box-shadow: 0 0 0 4px rgba(107, 203, 119, 0.28), 0 12px 28px rgba(0, 0, 0, 0.25);
        }

        .impro-key.playing.white {
            background: rgba(107, 203, 119, 0.92);
        }

        .impro-key.playing.black {
            background: rgba(107, 203, 119, 0.85);
        }

        .impro-key.contrast {
            box-shadow: 0 0 0 4px rgba(255, 107, 255, 0.28), 0 12px 28px rgba(0, 0, 0, 0.25);
        }

        .impro-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            justify-content: center;
            margin-top: 1.3rem;
        }

        .impro-mix {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.8rem;
            margin-top: 1.2rem;
            flex-wrap: wrap;
        }

        .impro-slider {
            display: flex;
            align-items: center;
            gap: 0.6rem;
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        .impro-slider input[type="range"] {
            width: 140px;
        }

        .impro-loop-panel {
            margin-top: 1.5rem;
            background: rgba(0, 0, 0, 0.18);
            border: 1px solid rgba(255, 255, 255, 0.12);
            border-radius: 1.2rem;
            padding: 1rem 1.2rem;
        }

        .impro-loop-status {
            font-size: 0.95rem;
            color: var(--text-light);
            margin-bottom: 0.8rem;
        }

        .impro-loop-controls {
            display: flex;
            gap: 0.6rem;
            flex-wrap: wrap;
        }

        .impro-btn {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.14);
            border-radius: 2rem;
            padding: 0.9rem 1.4rem;
            font-family: 'Fredoka', sans-serif;
            font-size: 1.05rem;
            font-weight: 500;
            color: var(--text-light);
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
        }

        .impro-btn:hover {
            transform: translateY(-1px);
            background: rgba(255, 255, 255, 0.12);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.22);
        }

        .impro-btn.primary {
            background: linear-gradient(135deg, var(--accent-gold), var(--accent-warm));
            border-color: transparent;
            color: #1a1a2e;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .app-container {
                padding: 1rem;
            }

            .logo {
                font-size: 2.5rem;
            }

            .nav-tab {
                padding: 0.6rem 1rem;
                font-size: 0.9rem;
            }

            .worlds-grid {
                grid-template-columns: 1fr;
            }

            .diary-header {
                flex-direction: column;
                gap: 1rem;
            }

            .echo-card {
                padding: 1.4rem;
            }

            .echo-piano {
                height: 160px;
            }

            .impro-card {
                padding: 1.4rem;
            }

            .impro-piano {
                height: 160px;
            }

            .island-map {
                padding: 1.6rem;
                min-height: 460px;
            }

            .island-landmark {
                min-width: 130px;
            }
        }

        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }

            .bg-particles {
                display: none;
            }

            .island-video {
                display: none;
            }
        }
    </style>
</head>
<body>
    <!-- Background particles -->
    <div class="bg-particles" id="particles"></div>

    <div class="app-container">
        <!-- Header -->
        <header class="header">
            <h1 class="logo">üéπ KlangReise</h1>
            <p class="tagline">Entdecke die Magie der Musik</p>
        </header>

        <!-- Navigation -->
        <nav class="nav-tabs">
            <button class="nav-tab active" data-screen="island">Insel</button>
            <button class="nav-tab" data-screen="welcome">Start</button>
            <button class="nav-tab" data-screen="play">Spielen</button>
            <button class="nav-tab" data-screen="worlds">Klangwelten</button>
            <button class="nav-tab" data-screen="diary">Klangtagebuch</button>
            <button class="nav-tab" data-screen="garden">Mein Garten</button>
        </nav>

        <!-- Island Screen -->
        <section class="screen active island-screen" id="island">
            <div class="island-title">Deine Klang-Insel</div>
            <div class="island-subtitle">Tippe ein Wahrzeichen an, um loszulegen.</div>
            <div class="island-map" id="islandMap" data-theme="sunrise">
                <video class="island-video" id="islandVideo" autoplay muted loop playsinline preload="metadata">
                    <source src="assets/video/island.mp4" type="video/mp4">
                </video>
                <div class="island-glow"></div>
                <button class="island-landmark" style="left: 8%; top: 18%;" data-landmark="echo" data-screen="play" data-module="echo">
                    <div class="landmark-icon">‚õ∞Ô∏è</div>
                    <div class="landmark-label">Echo-H√∂hlen</div>
                    <div class="landmark-badge" id="badgeEcho">Level 1</div>
                </button>
                <button class="island-landmark" style="right: 10%; top: 20%;" data-landmark="chords" data-screen="play" data-module="chords" data-disabled="true" disabled>
                    <div class="landmark-icon">üíé</div>
                    <div class="landmark-label">Kristall-Lagune</div>
                    <div class="landmark-badge">Bald</div>
                </button>
                <button class="island-landmark" style="left: 14%; bottom: 16%;" data-landmark="impro" data-screen="play" data-module="impro">
                    <div class="landmark-icon">üåæ</div>
                    <div class="landmark-label">Impro-Wiese</div>
                    <div class="landmark-badge" id="badgeImpro">Loops 0</div>
                </button>
                <button class="island-landmark" style="right: 12%; bottom: 18%;" data-landmark="stories" data-screen="play" data-module="stories" data-disabled="true" disabled>
                    <div class="landmark-icon">üå≥</div>
                    <div class="landmark-label">Vorlese-Eiche</div>
                    <div class="landmark-badge">Bald</div>
                </button>
                <button class="island-landmark" style="left: 52%; top: 12%;" data-landmark="feelings" data-screen="play" data-module="feelings" data-disabled="true" disabled>
                    <div class="landmark-icon">ü•ö</div>
                    <div class="landmark-label">Gef√ºhls-Nest</div>
                    <div class="landmark-badge">Bald</div>
                </button>
                <button class="island-garden" id="islandGarden" data-screen="garden">
                    <div class="landmark-icon">üåø</div>
                    <div class="landmark-label">Klanggarten</div>
                    <div class="landmark-badge" id="badgeGarden">Wachstum 0</div>
                </button>
            </div>
        </section>

        <!-- Welcome Screen -->
        <section class="screen" id="welcome">
            <div class="welcome-container">
                <div class="welcome-illustration">üéµ</div>
                <p class="welcome-text">
                    Hallo, kleiner Klangentdecker! üåü<br><br>
                    Hier gibt es keine richtigen oder falschen T√∂ne ‚Äì nur <em>deine</em> Musik.
                    Stell dein Klavier bereit und lass uns zusammen herausfinden, 
                    welche Geschichten heute in deinen Fingern stecken!
                </p>
                <button class="start-btn" id="startBtn">Los geht's! ‚ú®</button>
            </div>
        </section>

        <!-- Play Screen -->
        <section class="screen" id="play">
            <!-- Daily Prompt -->
            <div class="prompt-card">
                <div class="prompt-label">Heute k√∂nntest du...</div>
                <div class="prompt-text" id="dailyPrompt">Spiel mal, wie sich ein Schmetterling anh√∂rt! ü¶ã</div>
                <button class="prompt-refresh" id="newPromptBtn">Andere Idee üé≤</button>
            </div>

            <!-- Module Switch -->
            <div class="module-tabs" aria-label="Spielmodi">
                <button class="module-tab active" data-module="free">Frei</button>
                <button class="module-tab" data-module="echo">Echo</button>
                <button class="module-tab" data-module="chords" disabled>Akkorde</button>
                <button class="module-tab" data-module="stories" disabled>Geschichten</button>
                <button class="module-tab" data-module="impro">Impro</button>
                <button class="module-tab" data-module="feelings" disabled>Gef√ºhle</button>
            </div>

            <!-- Free Play -->
            <div class="module-screen active" id="module-free">
                <div class="play-container">
                    <!-- Visualization -->
                    <div class="visualization-area">
                        <div class="mood-label" id="moodLabel">Frei spielen</div>
                        <canvas class="visualization-canvas" id="visualizer"></canvas>
                    </div>

                    <!-- Notes Display -->
                    <div class="notes-display">
                        <div class="notes-label">Du spielst gerade:</div>
                        <div class="detected-note" id="currentNote">üéπ</div>
                        <div class="note-history" id="noteHistory"></div>
                    </div>

                    <!-- Controls -->
                    <div class="controls-area">
                        <button class="control-btn" id="micBtn" title="Mikrofon starten">üé§</button>
                        <button class="control-btn" id="recordBtn" title="Aufnehmen">‚è∫Ô∏è</button>
                        <button class="control-btn" id="saveBtn" title="Speichern">üíæ</button>
                    </div>
                </div>
            </div>

            <!-- Echo Game -->
            <div class="module-screen" id="module-echo">
                <div class="echo-card">
                    <div class="echo-celebrate" id="echoCelebrate" aria-hidden="true">‚ú®</div>
                    <div class="echo-header">
                        <div>
                            <div class="echo-title">Echo-Spiel</div>
                            <div class="echo-subtitle">Ich spiele vor. Du spielst nach Geh√∂r.</div>
                        </div>
                        <div class="echo-progress" id="echoProgress" aria-label="Reise-Fortschritt"></div>
                    </div>

                    <div class="echo-status" id="echoStatus">
                        Tippe auf <strong>Vorh√∂ren</strong> und spiel dann nach. Wenn du willst, darf es auch ein bisschen daneben sein.
                    </div>

                    <div class="echo-controls">
                        <button class="echo-btn primary" id="echoPlayBtn">‚ñ∂Ô∏è Vorh√∂ren</button>
                        <button class="echo-btn" id="echoReplayBtn" disabled>üîÅ Nochmal</button>
                        <button class="echo-btn" id="echoNextBtn" disabled>‚ú® Weiter</button>
                    </div>

                    <div class="echo-piano-wrap">
                        <div class="echo-piano" id="echoPiano" aria-label="Klaviatur (vereinfachte Anzeige)"></div>
                    </div>
                </div>
            </div>

            <!-- Impro Playground -->
            <div class="module-screen" id="module-impro">
                <div class="impro-card">
                    <div class="impro-header">
                        <div>
                            <div class="impro-title">Impro-Spielplatz</div>
                            <div class="impro-subtitle">Hier gibt es keine falschen Noten. Spiel, wie es sich gut anf√ºhlt.</div>
                        </div>
                    </div>

                    <div class="impro-worlds" id="improWorlds">
                        <div class="impro-world sun active" data-space="sun">
                            <strong>‚òÄÔ∏è Sonnengarten</strong>
                            <span>Leicht, hell, voller Schmetterlinge.</span>
                        </div>
                        <div class="impro-world moon" data-space="moon">
                            <strong>üåô Mondsee</strong>
                            <span>Tiefblau, ruhig, weit.</span>
                        </div>
                        <div class="impro-world adventure" data-space="adventure">
                            <strong>üî• Abenteuer-Fels</strong>
                            <span>Spannend, funkelnd, mutig.</span>
                        </div>
                    </div>

                    <div class="impro-status" id="improStatus">W√§hle eine Klangwiese und fang einfach an.</div>

                    <div class="impro-visual soft" id="improVisual">
                        <div class="impro-aura" id="improAura"></div>
                    </div>

                    <div class="impro-piano-wrap">
                        <div class="impro-piano" id="improPiano" aria-label="Klaviatur (safe-space)"></div>
                    </div>

                    <div class="impro-controls">
                        <button class="impro-btn primary" id="improListenBtn">üé§ Zuh√∂ren</button>
                        <button class="impro-btn" id="improResponseBtn">üå¨Ô∏è Antwort spielen</button>
                    </div>

                    <div class="impro-mix">
                        <label class="impro-slider">
                            Begleitung
                            <input type="range" id="improBackingVolume" min="0" max="1" step="0.01" value="0.35">
                        </label>
                        <label class="impro-slider">
                            Loop
                            <input type="range" id="improLoopVolume" min="0" max="1" step="0.01" value="0.85">
                        </label>
                    </div>

                    <div class="impro-loop-panel">
                        <div class="impro-loop-status" id="improLoopStatus">Kein Loop aufgenommen.</div>
                        <div class="impro-loop-controls">
                            <button class="impro-btn" id="improLoopBtn">üîÅ Loop aufnehmen</button>
                            <button class="impro-btn" id="improLoopClearBtn">üßπ Loops l√∂schen</button>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Klangwelten Screen -->
        <section class="screen" id="worlds">
            <div class="worlds-grid">
                <div class="world-card mysterious" data-world="mysterious">
                    <div class="world-icon">üîÆ</div>
                    <div class="world-name">Geheimnisvoll</div>
                    <div class="world-desc">Die schwarzen Tasten erz√§hlen magische Geschichten...</div>
                </div>
                <div class="world-card joyful" data-world="joyful">
                    <div class="world-icon">‚òÄÔ∏è</div>
                    <div class="world-name">Fr√∂hlich</div>
                    <div class="world-desc">Lass die T√∂ne h√ºpfen und tanzen!</div>
                </div>
                <div class="world-card dreamy" data-world="dreamy">
                    <div class="world-icon">üåô</div>
                    <div class="world-name">Vertr√§umt</div>
                    <div class="world-desc">Sanfte Kl√§nge wie Wolken am Himmel...</div>
                </div>
                <div class="world-card exciting" data-world="exciting">
                    <div class="world-icon">‚ö°</div>
                    <div class="world-name">Aufregend</div>
                    <div class="world-desc">Schnell, laut, voller Energie!</div>
                </div>
                <div class="world-card calm" data-world="calm">
                    <div class="world-icon">üåø</div>
                    <div class="world-name">Ruhig</div>
                    <div class="world-desc">Wie ein stiller See im Wald...</div>
                </div>
            </div>
        </section>

        <!-- Diary Screen -->
        <section class="screen" id="diary">
            <div class="diary-container">
                <div class="diary-header">
                    <h2 class="diary-title">üìî Mein Klangtagebuch</h2>
                    <div class="diary-stats">
                        <div class="stat-item">
                            <div class="stat-value" id="totalRecordings">0</div>
                            <div class="stat-label">Aufnahmen</div>
                        </div>
                        <div class="stat-item">
                            <div class="stat-value" id="totalMinutes">0</div>
                            <div class="stat-label">Minuten</div>
                        </div>
                    </div>
                </div>
                <div class="diary-entries" id="diaryEntries">
                    <div class="empty-diary">
                        <div class="empty-diary-icon">üéµ</div>
                        <p>Noch keine Aufnahmen ‚Äì deine erste Klanggeschichte wartet auf dich!</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Garden Screen -->
        <section class="screen" id="garden">
            <div class="garden-container">
                <h2 class="garden-title">üå± Mein Klanggarten</h2>
                <p class="garden-subtitle">Jede Entdeckung l√§sst etwas wachsen...</p>
                <div class="garden-visual" id="gardenVisual">
                    <div class="garden-message">Spiele und entdecke, um deinen Garten wachsen zu lassen!</div>
                    <div class="garden-ground"></div>
                </div>
            </div>
        </section>
    </div>

    <button class="compass-btn hidden" id="compassBtn" aria-label="Zur Insel">üß≠</button>

    <!-- Microphone Permission Modal -->
    <div class="modal-overlay" id="micModal">
        <div class="modal-content">
            <div class="modal-icon">üé§</div>
            <h3 class="modal-title">Darf ich zuh√∂ren?</h3>
            <p class="modal-text">
                Damit ich h√∂ren kann, was du spielst, brauche ich Zugriff auf dein Mikrofon. 
                Keine Sorge ‚Äì ich speichere nichts ohne deine Erlaubnis!
            </p>
            <button class="modal-btn" id="allowMicBtn">Ja, h√∂r zu! üëÇ</button>
        </div>
    </div>

    <script>
        // ==================== STORAGE HELPERS ====================
        function safeJsonParse(value, fallback) {
            try {
                return JSON.parse(value);
            } catch (_) {
                return fallback;
            }
        }

        function clampNumber(value, min, max) {
            return Math.min(max, Math.max(min, value));
        }

        function loadEchoProgress() {
            const fallback = { level: 1 };
            const parsed = safeJsonParse(localStorage.getItem('klangreise_echo') || 'null', null);
            if (!parsed || typeof parsed !== 'object') return fallback;
            const level = typeof parsed.level === 'number' ? parsed.level : fallback.level;
            return { level: clampNumber(level, 1, 5) };
        }

        function saveEchoProgress(progress) {
            try {
                localStorage.setItem('klangreise_echo', JSON.stringify(progress));
            } catch (err) {
                console.warn('Could not save echo progress:', err);
            }
        }

        function loadImproPrefs() {
            const fallback = { space: 'sun', backingVolume: 0.35, loopVolume: 0.85 };
            const parsed = safeJsonParse(localStorage.getItem('klangreise_impro') || 'null', null);
            if (!parsed || typeof parsed !== 'object') return fallback;
            if (typeof parsed.space !== 'string') return fallback;
            return {
                space: parsed.space,
                backingVolume: typeof parsed.backingVolume === 'number' ? parsed.backingVolume : fallback.backingVolume,
                loopVolume: typeof parsed.loopVolume === 'number' ? parsed.loopVolume : fallback.loopVolume
            };
        }

        function saveImproPrefs(prefs) {
            try {
                localStorage.setItem('klangreise_impro', JSON.stringify(prefs));
            } catch (err) {
                console.warn('Could not save impro prefs:', err);
            }
        }

        const defaultAppState = {
            user: {
                ageGroup: 'entdecker',
                currentIslandTheme: 'sunrise',
                lastVisit: Date.now(),
                introSeen: false
            },
            garden: {
                unlockedPlants: [],
                growthPoints: 0
            },
            progress: {
                echoCave: { currentLevel: 1, completed: 0 },
                chordLagoon: { discoveredEmotions: [], totalChords: 0 },
                storyTree: { completedStories: [] },
                improMeadow: { loopsRecorded: 0, sessions: 0 },
                feelingsNest: { used: 0 }
            },
            session: {
                activeScreen: 'island',
                activeModule: 'free',
                audioContextStarted: false
            }
        };

        function deepMerge(target, source) {
            if (!source || typeof source !== 'object') return target;
            Object.keys(source).forEach((key) => {
                const value = source[key];
                if (value && typeof value === 'object' && !Array.isArray(value)) {
                    if (!target[key] || typeof target[key] !== 'object') target[key] = {};
                    deepMerge(target[key], value);
                } else {
                    target[key] = value;
                }
            });
            return target;
        }

        function loadAppState() {
            const fallback = JSON.parse(JSON.stringify(defaultAppState));
            const parsed = safeJsonParse(localStorage.getItem('klangreise_state') || 'null', null);
            if (!parsed || typeof parsed !== 'object') return fallback;
            return deepMerge(fallback, parsed);
        }

        function saveAppState() {
            try {
                localStorage.setItem('klangreise_state', JSON.stringify(appState));
            } catch (err) {
                console.warn('Could not save app state:', err);
            }
        }

        const appState = loadAppState();

        // ==================== APP STATE ====================
        const state = {
            isListening: false,
            isRecording: false,
            currentWorld: null,
            currentModule: appState.session.activeModule || 'free',
            audioContext: null,
            analyser: null,
            microphone: null,
            mediaStream: null,
            recordings: JSON.parse(localStorage.getItem('klangreise_recordings') || '[]'),
            gardenProgress: Math.max(
                parseInt(localStorage.getItem('klangreise_garden') || '0'),
                appState.garden.growthPoints || 0
            ),
            noteHistory: [],
            recordedChunks: [],
            mediaRecorder: null,
            recordingStart: null,
            recordingStop: null,
            echoProgress: loadEchoProgress(),
            echo: {
                mode: 'idle', // idle | playing | awaiting | success
                level: 1,
                maxLevel: 5,
                expected: [],
                step: 0,
                mistakes: 0,
                isPlaying: false,
                playTimeouts: [],
                playNodes: [],
                pendingStart: false,
                currentOctave: 4,
                missTimeout: null,
                lastHintAt: 0,
                lastHintStep: -1,
                heardRecently: null,
                lastRoundId: 0
            },
            improPrefs: loadImproPrefs(),
            impro: {
                currentSpace: 'sun',
                currentScale: 'pentatonic_major',
                bpm: 90,
                tempoSamples: [],
                lastNoteAt: 0,
                lastResponseAt: 0,
                callTimeout: null,
                backingTimer: null,
                isBacking: false,
                responseEnabled: true,
                pendingStart: false,
                timeouts: [],
                visualTimeout: null,
                backingVolume: 0.35,
                loopVolume: 0.85,
                backingGain: 0.012,
                backingTracks: {},
                backingReady: {},
                activeBackingId: null,
                backingIntensity: 0,
                loops: [],
                isLoopRecording: false,
                loopRecorder: null,
                loopChunks: [],
                loopTimer: null,
                loopDurationMs: 4000,
                pendingLoopStart: false
            },
            pitchTracker: {
                stableFramesNeeded: 4,
                minMsBetweenNotes: 220,
                candidatePitchClass: null,
                candidateFrames: 0,
                lastEmittedPitchClass: null,
                lastEmittedAt: 0
            }
        };

        const VISUALIZATION_FPS = 30;
        const NOTE_DETECT_MS = 60;
        const GARDEN_SAVE_MS = 1000;
        const reduceMotionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');

        let gardenSaveTimeout = null;
        let visualizerStarted = false;
        let visualizerResize = null;
        let activeAudio = null;

        // ==================== PROMPTS ====================
        const prompts = [
            "Spiel mal, wie sich ein Schmetterling anh√∂rt! ü¶ã",
            "Wie klingt es, wenn es regnet? üåßÔ∏è",
            "Kannst du einen Elefanten spielen? üêò",
            "Wie h√∂rt sich dein Lieblingstier an?",
            "Spiel mal ganz leise... und dann ganz laut!",
            "Wie klingt ein Sonnenaufgang? ‚òÄÔ∏è",
            "Kannst du Fr√∂hlichkeit spielen?",
            "Wie h√∂rt sich Nebel an? üå´Ô∏è",
            "Spiel mal nur mit einem Finger!",
            "Wie klingt ein springender Ball?",
            "Kannst du eine Wolke spielen? ‚òÅÔ∏è",
            "Wie h√∂rt sich Aufregung an?",
            "Spiel mal, wie du dich gerade f√ºhlst!",
            "Wie klingt ein Geheimnis? ü§´",
            "Kannst du eine Geschichte ohne Worte erz√§hlen?"
        ];

        // ==================== MUSIC HELPERS ====================
        const flatToSharp = {
            'Db': 'C#',
            'Eb': 'D#',
            'Gb': 'F#',
            'Ab': 'G#',
            'Bb': 'A#'
        };

        const echoWhiteNotes = ["C", "D", "E", "F", "G", "A", "B"];

        const echoPhrases = [
            { id: 'jakob', notes: ["C", "D", "E", "C"] },        // Bruder Jakob (Anfang)
            { id: 'entchen', notes: ["C", "D", "E", "F"] },      // Alle meine Entchen (Anfang)
            { id: 'twinkle', notes: ["C", "C", "G", "G"] },      // Twinkle (Anfang)
            { id: 'mary', notes: ["E", "D", "C", "D"] }          // Mary had a little lamb (Motiv)
        ];

        const improScales = {
            pentatonic_major: [0, 2, 4, 7, 9], // C, D, E, G, A
            moon_minor: [0, 3, 5, 7, 10],      // C, Eb, F, G, Bb
            blues: [0, 3, 5, 6, 7, 10]         // C, Eb, F, Gb, G, Bb
        };

        const improSpaces = [
            {
                id: 'sun',
                name: 'Sonnengarten',
                scale: 'pentatonic_major',
                color: '#ffd93d',
                vibe: 'hell und fr√∂hlich',
                emoji: 'ü¶ã'
            },
            {
                id: 'moon',
                name: 'Mondsee',
                scale: 'moon_minor',
                color: '#4d96ff',
                vibe: 'ruhig und weit',
                emoji: 'üåô'
            },
            {
                id: 'adventure',
                name: 'Abenteuer-Fels',
                scale: 'blues',
                color: '#9b5de5',
                vibe: 'mutig und spannend',
                emoji: 'üî•'
            }
        ];

        function normalizeNoteName(noteName) {
            return flatToSharp[noteName] || noteName;
        }

        function noteNameToPitchClass(noteName) {
            const normalized = normalizeNoteName(noteName);
            return noteStrings.indexOf(normalized);
        }

        function pitchClassDistance(a, b) {
            const diff = Math.abs(a - b);
            return Math.min(diff, 12 - diff);
        }

        function midiToFrequency(midi) {
            return 440 * Math.pow(2, (midi - 69) / 12);
        }

        function noteNameToMidi(noteName, octave) {
            const pc = noteNameToPitchClass(noteName);
            if (pc < 0) return null;
            return (octave + 1) * 12 + pc;
        }

        // ==================== NOTE DETECTION ====================
        const noteStrings = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
        
        function frequencyToNote(frequency) {
            if (frequency < 20 || frequency > 5000) return null;
            const noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
            const note = Math.round(noteNum) + 69;
            const octave = Math.floor(note / 12) - 1;
            const noteName = noteStrings[note % 12];
            const exactMidi = noteNum + 69;
            const cents = (exactMidi - note) * 100;
            return {
                name: noteName,
                octave: octave,
                full: `${noteName}${octave}`,
                frequency: frequency,
                cents: cents,
                midi: note
            };
        }

        function autoCorrelate(buffer, sampleRate) {
            let SIZE = buffer.length;
            let sumOfSquares = 0;
            for (let i = 0; i < SIZE; i++) {
                const val = buffer[i];
                sumOfSquares += val * val;
            }
            const rootMeanSquare = Math.sqrt(sumOfSquares / SIZE);
            if (rootMeanSquare < 0.01) return -1;

            let r1 = 0, r2 = SIZE - 1;
            const threshold = 0.2;
            for (let i = 0; i < SIZE / 2; i++) {
                if (Math.abs(buffer[i]) < threshold) { r1 = i; break; }
            }
            for (let i = 1; i < SIZE / 2; i++) {
                if (Math.abs(buffer[SIZE - i]) < threshold) { r2 = SIZE - i; break; }
            }

            buffer = buffer.slice(r1, r2);
            SIZE = buffer.length;

            const c = new Array(SIZE).fill(0);
            for (let i = 0; i < SIZE; i++) {
                for (let j = 0; j < SIZE - i; j++) {
                    c[i] += buffer[j] * buffer[j + i];
                }
            }

            let d = 0;
            while (c[d] > c[d + 1]) d++;
            let maxval = -1, maxpos = -1;
            for (let i = d; i < SIZE; i++) {
                if (c[i] > maxval) {
                    maxval = c[i];
                    maxpos = i;
                }
            }
            let T0 = maxpos;

            const x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1];
            const a = (x1 + x3 - 2 * x2) / 2;
            const b = (x3 - x1) / 2;
            if (a) T0 -= b / (2 * a);

            return sampleRate / T0;
        }

        // ==================== AUDIO SETUP ====================
        async function setupAudio() {
            try {
                state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                state.mediaStream = stream;

                if (state.audioContext.state === 'suspended') {
                    await state.audioContext.resume();
                }
                
                state.microphone = state.audioContext.createMediaStreamSource(stream);
                state.analyser = state.audioContext.createAnalyser();
                state.analyser.fftSize = 2048;
                state.microphone.connect(state.analyser);

                // Setup MediaRecorder for recordings
                if (typeof MediaRecorder !== 'undefined') {
                    state.mediaRecorder = new MediaRecorder(stream);
                    state.mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) state.recordedChunks.push(e.data);
                    };
                    state.mediaRecorder.onstop = saveRecording;
                } else {
                    state.mediaRecorder = null;
                    console.warn('MediaRecorder is not supported in this browser.');
                }

                appState.session.audioContextStarted = true;
                saveAppState();

                return true;
            } catch (err) {
                console.error('Audio setup failed:', err);
                return false;
            }
        }

        // ==================== ISLAND + NAVIGATION ====================
        function getIslandTheme() {
            const hour = new Date().getHours();
            if (hour >= 20 || hour < 6) return 'night';
            if (hour >= 6 && hour < 11) return 'sunrise';
            if (hour >= 17 && hour < 20) return 'sunset';
            return 'day';
        }

        function applyIslandTheme() {
            const theme = getIslandTheme();
            appState.user.currentIslandTheme = theme;
            appState.user.lastVisit = Date.now();
            saveAppState();
            const map = document.getElementById('islandMap');
            if (map) map.dataset.theme = theme;
        }

        function updateIslandView() {
            const echoBadge = document.getElementById('badgeEcho');
            const improBadge = document.getElementById('badgeImpro');
            const gardenBadge = document.getElementById('badgeGarden');

            if (echoBadge) {
                const level = appState.progress.echoCave.currentLevel || state.echo.level || 1;
                echoBadge.textContent = `Level ${level}`;
            }
            if (improBadge) {
                improBadge.textContent = `Loops ${appState.progress.improMeadow.loopsRecorded || 0}`;
            }
            if (gardenBadge) {
                gardenBadge.textContent = `Wachstum ${appState.garden.growthPoints || 0}`;
            }
        }

        function updateIslandVideoPlayback(screenId) {
            const video = document.getElementById('islandVideo');
            if (!video) return;
            if (reduceMotionQuery.matches) {
                video.pause();
                return;
            }
            if (screenId === 'island') {
                // Muted autoplay should work on iOS/Safari, but keep this safe.
                video.muted = true;
                video.play().catch(() => {});
            } else {
                video.pause();
            }
        }

        function updateCompassVisibility(screenId) {
            const compass = document.getElementById('compassBtn');
            if (!compass) return;
            const hide = screenId === 'island' || screenId === 'welcome';
            compass.classList.toggle('hidden', hide);
        }

        function openScreen(screenId) {
            document.body.classList.toggle('island-mode', screenId === 'island');
            document.querySelectorAll('.nav-tab').forEach((tab) => {
                tab.classList.toggle('active', tab.dataset.screen === screenId);
            });
            document.querySelectorAll('.screen').forEach((screen) => {
                screen.classList.toggle('active', screen.id === screenId);
            });

            if (screenId === 'garden') updateGardenView();
            if (screenId === 'diary') updateDiaryView();
            if (screenId === 'island') {
                applyIslandTheme();
                updateIslandView();
            }
            if (screenId === 'play') {
                const candidate = state.currentModule || 'free';
                const exists = document.getElementById(`module-${candidate}`);
                setActiveModule(exists ? candidate : 'free');
            }

            updateIslandVideoPlayback(screenId);

            appState.session.activeScreen = screenId;
            appState.session.activeModule = state.currentModule;
            saveAppState();
            updateCompassVisibility(screenId);
        }

        function openModule(moduleName) {
            const target = document.getElementById(`module-${moduleName}`);
            if (!target) return;
            state.currentModule = moduleName;
            openScreen('play');
        }

        // ==================== MODULE SWITCH (INSIDE PLAY) ====================
        function setActiveModule(moduleName) {
            state.currentModule = moduleName;
            document.querySelectorAll('.module-tab').forEach(t => {
                t.classList.toggle('active', t.dataset.module === moduleName);
            });
            document.querySelectorAll('.module-screen').forEach(s => {
                s.classList.toggle('active', s.id === `module-${moduleName}`);
            });

            appState.session.activeModule = moduleName;
            saveAppState();

            if (moduleName === 'echo') {
                enterEchoMode();
            } else {
                exitEchoMode();
            }

            if (moduleName === 'impro') {
                enterImproMode();
            } else {
                exitImproMode();
            }

            if (moduleName === 'free' && state.audioContext) {
                // Fix canvas sizing when returning from a hidden state (e.g. after enabling mic in Echo).
                setupVisualization();
            }
        }

        function setupModuleTabs() {
            document.querySelectorAll('.module-tab').forEach(tab => {
                if (tab.disabled) return;
                tab.addEventListener('click', () => setActiveModule(tab.dataset.module));
            });
        }

        // ==================== ECHO GAME ====================
        const echoLevels = [
            { level: 1, length: 2, allowBlack: false, tempoMs: 650, octave: 4 },
            { level: 2, length: 2, allowBlack: false, tempoMs: 520, octave: 4 },
            { level: 3, length: 4, allowBlack: true, tempoMs: 460, octave: 4 },
            { level: 4, length: 4, allowBlack: false, tempoMs: 480, octave: 4, phrases: echoPhrases },
            { level: 5, length: 4, allowBlack: true, tempoMs: 430, octave: 4, rhythm: [520, 260, 260, 520] }
        ];

        const echoUI = {
            pianoEl: null,
            statusEl: null,
            progressEl: null,
            playBtn: null,
            replayBtn: null,
            nextBtn: null,
            celebrateEl: null,
            whiteContainer: null,
            magnetEl: null
        };

        function initEchoGame() {
            echoUI.pianoEl = document.getElementById('echoPiano');
            echoUI.statusEl = document.getElementById('echoStatus');
            echoUI.progressEl = document.getElementById('echoProgress');
            echoUI.playBtn = document.getElementById('echoPlayBtn');
            echoUI.replayBtn = document.getElementById('echoReplayBtn');
            echoUI.nextBtn = document.getElementById('echoNextBtn');
            echoUI.celebrateEl = document.getElementById('echoCelebrate');

            state.echo.level = clampNumber(state.echoProgress.level || 1, 1, state.echo.maxLevel);
            appState.progress.echoCave.currentLevel = Math.max(
                appState.progress.echoCave.currentLevel || 1,
                state.echo.level
            );
            appState.garden.growthPoints = Math.max(appState.garden.growthPoints || 0, state.gardenProgress || 0);
            saveAppState();
            renderEchoProgress();
            renderEchoPiano();
            updateEchoControls();

            echoUI.playBtn.addEventListener('click', () => {
                startEchoRound({ replay: false });
            });
            echoUI.replayBtn.addEventListener('click', () => {
                startEchoRound({ replay: true });
            });
            echoUI.nextBtn.addEventListener('click', () => {
                advanceEchoLevel();
                startEchoRound({ replay: false });
            });

            window.addEventListener('resize', layoutEchoBlackKeys, { passive: true });
        }

        function renderEchoProgress() {
            if (!echoUI.progressEl) return;
            const filled = clampNumber(state.echo.level, 1, state.echo.maxLevel);
            echoUI.progressEl.innerHTML = Array.from({ length: state.echo.maxLevel }, (_, i) => {
                const cls = i < filled ? 'echo-dot filled' : 'echo-dot';
                return `<span class="${cls}" aria-hidden="true"></span>`;
            }).join('');
        }

        function renderEchoPiano() {
            if (!echoUI.pianoEl) return;

            echoUI.pianoEl.innerHTML = '';
            const whiteWrap = document.createElement('div');
            whiteWrap.className = 'echo-white-keys';
            echoUI.whiteContainer = whiteWrap;
            echoUI.pianoEl.appendChild(whiteWrap);

            const magnet = document.createElement('div');
            magnet.className = 'echo-magnet';
            echoUI.magnetEl = magnet;
            echoUI.pianoEl.appendChild(magnet);

            // White keys (one octave: C D E F G A B)
            echoWhiteNotes.forEach((n) => {
                const key = document.createElement('div');
                key.className = 'echo-key white';
                key.dataset.note = n;
                key.setAttribute('aria-label', `Taste ${n}`);
                whiteWrap.appendChild(key);
            });

            // Black keys (C#, D#, F#, G#, A#)
            const blackNotes = ["C#", "D#", "F#", "G#", "A#"];
            blackNotes.forEach((n) => {
                const key = document.createElement('div');
                key.className = 'echo-key black';
                key.dataset.note = n;
                key.setAttribute('aria-label', `Taste ${n}`);
                echoUI.pianoEl.appendChild(key);
            });

            layoutEchoBlackKeys();
        }

        function layoutEchoBlackKeys() {
            if (!echoUI.pianoEl || !echoUI.whiteContainer) return;
            const pianoRect = echoUI.pianoEl.getBoundingClientRect();
            const whiteKeys = Array.from(echoUI.whiteContainer.querySelectorAll('.echo-key.white'));
            if (!pianoRect.width || whiteKeys.length < 7) return;

            const blackMap = {
                "C#": ["C", "D"],
                "D#": ["D", "E"],
                "F#": ["F", "G"],
                "G#": ["G", "A"],
                "A#": ["A", "B"]
            };

            const getWhiteByNote = (name) => whiteKeys[echoWhiteNotes.indexOf(name)];
            const firstWhiteRect = whiteKeys[0].getBoundingClientRect();
            const whiteW = firstWhiteRect.width;
            const blackW = Math.max(24, Math.floor(whiteW * 0.62));

            echoUI.pianoEl.querySelectorAll('.echo-key.black').forEach((blackEl) => {
                const pair = blackMap[blackEl.dataset.note];
                if (!pair) return;
                const leftWhite = getWhiteByNote(pair[0]);
                const rightWhite = getWhiteByNote(pair[1]);
                if (!leftWhite || !rightWhite) return;
                const leftRect = leftWhite.getBoundingClientRect();
                const rightRect = rightWhite.getBoundingClientRect();
                const center = (leftRect.right + rightRect.left) / 2 - pianoRect.left;
                blackEl.style.width = `${blackW}px`;
                blackEl.style.left = `${Math.round(center - blackW / 2)}px`;
            });
        }

        function setEchoStatus(text) {
            if (!echoUI.statusEl) return;
            echoUI.statusEl.textContent = text;
        }

        function updateEchoControls() {
            if (!echoUI.playBtn) return;
            const isPlaying = state.echo.isPlaying;
            echoUI.playBtn.disabled = isPlaying;
            echoUI.replayBtn.disabled = isPlaying || state.echo.expected.length === 0;
            echoUI.nextBtn.disabled = isPlaying || state.echo.mode !== 'success';

            if (!state.audioContext && state.currentModule === 'echo') {
                setEchoStatus('Tippe auf Vorh√∂ren. Dann frage ich dich nach dem Mikrofon.');
            }
        }

        function enterEchoMode() {
            state.echo.mode = 'idle';
            state.echo.mistakes = 0;
            state.echo.step = 0;
            updateEchoControls();
        }

        function exitEchoMode() {
            if (state.echo.isPlaying) cancelEchoPlayback();
            state.echo.mode = 'idle';
            state.echo.step = 0;
            state.echo.mistakes = 0;
            clearEchoMissTimeout();
            setEchoTarget(null);
            if (echoUI.magnetEl) echoUI.magnetEl.classList.remove('active');
        }

        function getEchoLevelConfig() {
            const lvl = clampNumber(state.echo.level, 1, state.echo.maxLevel);
            return echoLevels.find(l => l.level === lvl) || echoLevels[0];
        }

        function getEchoTolerance(level) {
            const successThreshold = 30;
            const magneticThreshold = level <= 2 ? 120 : 100;
            return { successThreshold, magneticThreshold };
        }

        function evaluateEchoNote(targetFreq, playedFreq, level) {
            if (!targetFreq || !playedFreq) return 'MISS';
            if (!isFinite(targetFreq) || !isFinite(playedFreq)) return 'MISS';
            if (targetFreq <= 0 || playedFreq <= 0) return 'MISS';
            const distanceInCents = 1200 * Math.log2(playedFreq / targetFreq);
            const absDistance = Math.abs(distanceInCents);
            const { successThreshold, magneticThreshold } = getEchoTolerance(level);

            if (absDistance <= successThreshold) return 'MATCH';
            if (absDistance <= magneticThreshold) return 'NEAR';
            return 'MISS';
        }

        function pickRandom(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        function generateEchoSequence(levelConfig) {
            if (levelConfig.phrases && levelConfig.phrases.length) {
                const phrase = pickRandom(levelConfig.phrases);
                return phrase.notes.slice(0, levelConfig.length);
            }

            const allowBlack = !!levelConfig.allowBlack;
            const allowed = allowBlack ? noteStrings.slice() : echoWhiteNotes.slice();
            const seq = [];
            const maxAttempts = 40;

            for (let i = 0; i < levelConfig.length; i++) {
                let candidate = null;
                for (let attempt = 0; attempt < maxAttempts; attempt++) {
                    const next = pickRandom(allowed);
                    if (i === 0) {
                        candidate = next;
                        break;
                    }
                    const prevPc = noteNameToPitchClass(seq[i - 1]);
                    const nextPc = noteNameToPitchClass(next);
                    if (prevPc < 0 || nextPc < 0) continue;
                    if (next === seq[i - 1]) continue;

                    const minDist = levelConfig.level === 1 ? 4 : 1;
                    if (pitchClassDistance(prevPc, nextPc) < minDist) continue;
                    candidate = next;
                    break;
                }
                seq.push(candidate || pickRandom(allowed));
            }

            return seq;
        }

        function cancelEchoPlayback() {
            state.echo.playTimeouts.forEach(clearTimeout);
            state.echo.playTimeouts = [];

            state.echo.playNodes.forEach((n) => {
                try { n.osc.stop(); } catch (_) {}
                try { n.osc.disconnect(); } catch (_) {}
                try { n.gain.disconnect(); } catch (_) {}
            });
            state.echo.playNodes = [];
            state.echo.isPlaying = false;

            // Remove "playing" highlights
            if (echoUI.pianoEl) {
                echoUI.pianoEl.querySelectorAll('.echo-key.playing').forEach(k => k.classList.remove('playing'));
                echoUI.pianoEl.querySelectorAll('.echo-key.heard').forEach(k => k.classList.remove('heard'));
            }
        }

        function clearEchoMissTimeout() {
            if (state.echo.missTimeout) {
                clearTimeout(state.echo.missTimeout);
                state.echo.missTimeout = null;
            }
        }

        function setEchoTarget(noteName) {
            if (!echoUI.pianoEl) return;
            echoUI.pianoEl.querySelectorAll('.echo-key.target').forEach(k => k.classList.remove('target'));
            if (!noteName) return;
            const normalized = normalizeNoteName(noteName);
            const el = echoUI.pianoEl.querySelector(`.echo-key[data-note="${normalized}"]`);
            if (el) el.classList.add('target');
        }

        function flashEchoTarget(noteName) {
            if (!echoUI.pianoEl) return;
            const normalized = normalizeNoteName(noteName);
            const el = echoUI.pianoEl.querySelector(`.echo-key[data-note="${normalized}"]`);
            if (!el) return;
            el.classList.add('flash');
            const t = setTimeout(() => el.classList.remove('flash'), 350);
            state.echo.playTimeouts.push(t);
        }

        function showMagnetFlow(fromNote, toNote) {
            if (!echoUI.magnetEl || !echoUI.pianoEl) return;
            const fromEl = echoUI.pianoEl.querySelector(`.echo-key[data-note="${normalizeNoteName(fromNote)}"]`);
            const toEl = echoUI.pianoEl.querySelector(`.echo-key[data-note="${normalizeNoteName(toNote)}"]`);
            if (!fromEl || !toEl) return;

            const pianoRect = echoUI.pianoEl.getBoundingClientRect();
            const fromRect = fromEl.getBoundingClientRect();
            const toRect = toEl.getBoundingClientRect();
            const fromX = fromRect.left + fromRect.width / 2 - pianoRect.left - 8;
            const fromY = fromRect.top + fromRect.height / 2 - pianoRect.top - 8;
            const toX = toRect.left + toRect.width / 2 - pianoRect.left - 8;
            const toY = toRect.top + toRect.height / 2 - pianoRect.top - 8;

            echoUI.magnetEl.classList.remove('active');
            echoUI.magnetEl.style.transform = `translate(${fromX}px, ${fromY}px)`;
            // Force reflow for transition
            void echoUI.magnetEl.offsetWidth;
            echoUI.magnetEl.classList.add('active');
            echoUI.magnetEl.style.transform = `translate(${toX}px, ${toY}px)`;

            const t = setTimeout(() => {
                if (echoUI.magnetEl) echoUI.magnetEl.classList.remove('active');
            }, 520);
            state.echo.playTimeouts.push(t);
        }

        function playEchoWhisper(noteName) {
            if (!state.audioContext) return;
            const midi = noteNameToMidi(noteName, state.echo.currentOctave || 4);
            const freq = midi ? midiToFrequency(midi) : null;
            if (!freq) return;

            const ctx = state.audioContext;
            const when = ctx.currentTime + 0.02;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(freq, when);
            gain.gain.setValueAtTime(0.0001, when);
            gain.gain.linearRampToValueAtTime(0.05, when + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.0001, when + 0.26);
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start(when);
            osc.stop(when + 0.3);
            state.echo.playNodes.push({ osc, gain });
            highlightEchoKey(noteName, 'playing', 220);
        }

        function playEchoChime() {
            if (!state.audioContext) return;
            const ctx = state.audioContext;
            const when = ctx.currentTime + 0.02;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(880, when);
            gain.gain.setValueAtTime(0.0001, when);
            gain.gain.linearRampToValueAtTime(0.08, when + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.0001, when + 0.35);
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start(when);
            osc.stop(when + 0.4);
            state.echo.playNodes.push({ osc, gain });
        }

        function highlightEchoKey(noteName, className, holdMs) {
            if (!echoUI.pianoEl) return;
            const normalized = normalizeNoteName(noteName);
            const el = echoUI.pianoEl.querySelector(`.echo-key[data-note="${normalized}"]`);
            if (!el) return;
            el.classList.add(className);
            if (!holdMs) return;
            const t = setTimeout(() => el.classList.remove(className), holdMs);
            state.echo.playTimeouts.push(t);
        }

        async function playEchoSequence(sequence, levelConfig) {
            if (!state.audioContext) return;
            if (state.audioContext.state === 'suspended') {
                try { await state.audioContext.resume(); } catch (_) {}
            }

            cancelEchoPlayback();
            clearEchoMissTimeout();
            state.echo.isPlaying = true;
            state.echo.mode = 'playing';
            updateEchoControls();

            const ctx = state.audioContext;
            const tempoMs = levelConfig.tempoMs;
            const rhythm = Array.isArray(levelConfig.rhythm) ? levelConfig.rhythm : null;
            const baseOctave = typeof levelConfig.octave === 'number' ? levelConfig.octave : 4;
            state.echo.currentOctave = baseOctave;
            const startAt = ctx.currentTime + 0.08;

            let cursor = 0;
            sequence.forEach((noteName, i) => {
                const durMs = rhythm ? (rhythm[i] || tempoMs) : tempoMs;
                const durSec = Math.max(0.14, durMs / 1000);
                const when = startAt + cursor;
                cursor += durSec + 0.05;

                const midi = noteNameToMidi(noteName, baseOctave);
                const freq = midi ? midiToFrequency(midi) : null;
                if (!freq) return;

                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(freq, when);

                // Gentle envelope, low volume (helps against mic feedback).
                const peak = 0.12;
                gain.gain.setValueAtTime(0.0001, when);
                gain.gain.linearRampToValueAtTime(peak, when + 0.02);
                gain.gain.exponentialRampToValueAtTime(0.0001, when + durSec);

                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(when);
                osc.stop(when + durSec + 0.03);

                state.echo.playNodes.push({ osc, gain });

                const now = performance.now();
                const delayMs = Math.max(0, Math.round((when - startAt) * 1000));
                state.echo.playTimeouts.push(setTimeout(() => {
                    highlightEchoKey(noteName, 'playing', Math.max(180, Math.round(durSec * 1000)));
                }, delayMs));
            });

            const totalMs = Math.round((cursor + 0.1) * 1000);
            await new Promise((resolve) => {
                const t = setTimeout(resolve, totalMs);
                state.echo.playTimeouts.push(t);
            });

            state.echo.isPlaying = false;
            state.echo.mode = 'awaiting';
            updateEchoControls();
            setEchoStatus('Jetzt du. H√∂r mit deinen Ohren und spiel es nach.');
            setEchoTarget(state.echo.expected[state.echo.step]);
        }

        async function startEchoRound({ replay }) {
            if (!state.audioContext) {
                state.echo.pendingStart = true;
                document.getElementById('micModal').classList.add('active');
                updateEchoControls();
                return;
            }

            // Echo-Spiel needs stable note events; turn listening on if it was toggled off.
            if (!state.isListening && state.analyser) {
                state.isListening = true;
                const micBtn = document.getElementById('micBtn');
                if (micBtn) micBtn.classList.add('listening');
                startNoteDetection();
            }

            const levelConfig = getEchoLevelConfig();
            state.echo.mistakes = 0;
            state.echo.step = 0;
            state.echo.mode = 'idle';
            state.echo.lastRoundId = Date.now();
            state.echo.lastHintStep = -1;
            state.echo.lastHintAt = 0;
            clearEchoMissTimeout();

            if (!replay || state.echo.expected.length === 0) {
                state.echo.expected = generateEchoSequence(levelConfig);
            }

            // Clear any "heard" highlights from a previous try.
            if (echoUI.pianoEl) {
                echoUI.pianoEl.querySelectorAll('.echo-key.heard').forEach(k => k.classList.remove('heard'));
            }
            setEchoTarget(null);

            setEchoStatus('Ich spiele vor...');
            await playEchoSequence(state.echo.expected, levelConfig);
            echoUI.replayBtn.disabled = false;
        }

        function advanceEchoLevel() {
            const nextLevel = clampNumber(state.echo.level + 1, 1, state.echo.maxLevel);
            state.echo.level = nextLevel;
            state.echoProgress.level = nextLevel;
            saveEchoProgress(state.echoProgress);
            appState.progress.echoCave.currentLevel = nextLevel;
            saveAppState();
            updateIslandView();
            renderEchoProgress();
            state.echo.mode = 'idle';
            state.echo.step = 0;
            state.echo.expected = [];
            updateEchoControls();
        }

        function echoCelebrate() {
            if (!echoUI.celebrateEl) return;
            echoUI.celebrateEl.classList.remove('active');
            // Force reflow so the animation restarts reliably.
            void echoUI.celebrateEl.offsetWidth;
            echoUI.celebrateEl.classList.add('active');
        }

        function onEchoStableNote(note) {
            if (state.currentModule !== 'echo') return;
            if (state.echo.isPlaying) return;
            if (state.echo.mode !== 'awaiting') return;
            if (!state.echo.expected.length) return;

            const pc = noteNameToPitchClass(note.name);
            if (pc < 0) return;

            highlightEchoKey(note.name, 'heard', 220);

            const expectedName = state.echo.expected[state.echo.step];
            const expectedPc = noteNameToPitchClass(expectedName);
            if (expectedPc < 0) return;

            const playedFreq = note.frequency || null;
            const targetMidi = noteNameToMidi(expectedName, state.echo.currentOctave || 4);
            const targetFreq = targetMidi ? midiToFrequency(targetMidi) : null;
            const result = evaluateEchoNote(targetFreq, playedFreq, state.echo.level);

            clearEchoMissTimeout();

            if (result === 'NEAR') {
                const now = performance.now();
                if (now - state.echo.lastHintAt > 700 || state.echo.lastHintStep !== state.echo.step) {
                    showMagnetFlow(note.name, expectedName);
                    setEchoStatus('Fast da. Such den Klang noch ein bisschen.');
                    state.echo.lastHintAt = now;
                    state.echo.lastHintStep = state.echo.step;
                }
                if (state.echo.level <= 2) {
                    // Early levels accept "near" to keep momentum.
                    handleEchoMatch();
                }
                return;
            }

            if (result === 'MISS') {
                state.echo.mistakes += 1;
                flashEchoTarget(expectedName);

                if (!state.echo.missTimeout) {
                    state.echo.missTimeout = setTimeout(() => {
                        state.echo.missTimeout = null;
                        if (state.echo.mode !== 'awaiting') return;
                        if (state.echo.isPlaying) return;
                        if (state.echo.expected[state.echo.step] !== expectedName) return;
                        playEchoWhisper(expectedName);
                    }, 2000);
                }

                if (state.echo.mistakes === 3) {
                    setEchoStatus('Wenn du magst, spiele ich es dir nochmal vor.');
                }
                if (state.echo.mistakes >= 6) {
                    state.echo.mistakes = 0;
                    startEchoRound({ replay: true });
                }
                return;
            }

            // MATCH
            handleEchoMatch();

            function handleEchoMatch() {
                highlightEchoKey(expectedName, 'playing', 260);
                state.echo.step += 1;
                state.echo.mistakes = 0;
                setEchoStatus('Sch√∂n! Und jetzt kommt noch ein Klang...');

                if (state.echo.step >= state.echo.expected.length) {
                    state.echo.mode = 'success';
                    setEchoStatus('Wow. Dein Echo war wundersch√∂n. Wenn du magst: weiter.');
                    echoCelebrate();
                    playEchoChime();
                    updateEchoControls();
                    setEchoTarget(null);
                    state.gardenProgress += 5;
                    scheduleGardenSave();
                    appState.progress.echoCave.completed = (appState.progress.echoCave.completed || 0) + 1;
                    appState.progress.echoCave.currentLevel = state.echo.level;
                    saveAppState();
                    updateIslandView();
                    return;
                }

                setEchoTarget(state.echo.expected[state.echo.step]);
            }
        }

        // ==================== IMPRO PLAYGROUND ====================
        const improUI = {
            worldsEl: null,
            statusEl: null,
            visualEl: null,
            auraEl: null,
            pianoEl: null,
            whiteContainer: null,
            listenBtn: null,
            responseBtn: null,
            loopStatusEl: null,
            loopBtn: null,
            loopClearBtn: null,
            backingVolumeInput: null,
            loopVolumeInput: null
        };

        function initImproPlayground() {
            improUI.worldsEl = document.getElementById('improWorlds');
            improUI.statusEl = document.getElementById('improStatus');
            improUI.visualEl = document.getElementById('improVisual');
            improUI.auraEl = document.getElementById('improAura');
            improUI.pianoEl = document.getElementById('improPiano');
            improUI.listenBtn = document.getElementById('improListenBtn');
            improUI.responseBtn = document.getElementById('improResponseBtn');
            improUI.loopStatusEl = document.getElementById('improLoopStatus');
            improUI.loopBtn = document.getElementById('improLoopBtn');
            improUI.loopClearBtn = document.getElementById('improLoopClearBtn');
            improUI.backingVolumeInput = document.getElementById('improBackingVolume');
            improUI.loopVolumeInput = document.getElementById('improLoopVolume');

            state.impro.currentSpace = state.improPrefs.space || 'sun';
            state.impro.backingVolume = clampNumber(state.improPrefs.backingVolume ?? 0.35, 0, 1);
            state.impro.loopVolume = clampNumber(state.improPrefs.loopVolume ?? 0.85, 0, 1);
            applyImproSpace(state.impro.currentSpace, { announce: false });
            renderImproPiano();
            initImproBackingTracks();
            updateImproLoopStatus();
            updateImproBackingIntensity();
            updateImproBackingVolume();

            if (improUI.worldsEl) {
                improUI.worldsEl.querySelectorAll('.impro-world').forEach((card) => {
                    card.addEventListener('click', () => {
                        applyImproSpace(card.dataset.space, { announce: true });
                    });
                });
            }

            if (improUI.listenBtn) {
                improUI.listenBtn.addEventListener('click', () => {
                    ensureImproListening(true);
                });
            }

            if (improUI.responseBtn) {
                improUI.responseBtn.addEventListener('click', () => {
                    if (state.currentModule !== 'impro') return;
                    playImproResponse(true);
                });
            }

            if (improUI.loopBtn) {
                improUI.loopBtn.addEventListener('click', () => {
                    if (state.currentModule !== 'impro') return;
                    startImproLoopRecording();
                });
            }

            if (improUI.loopClearBtn) {
                improUI.loopClearBtn.addEventListener('click', () => {
                    clearImproLoops();
                });
            }

            if (improUI.loopBtn && typeof MediaRecorder === 'undefined') {
                improUI.loopBtn.disabled = true;
                if (improUI.loopStatusEl) {
                    improUI.loopStatusEl.textContent = 'Loop-Aufnahme ist in diesem Browser nicht verfuegbar.';
                }
            }

            if (improUI.backingVolumeInput) {
                improUI.backingVolumeInput.value = state.impro.backingVolume;
                improUI.backingVolumeInput.addEventListener('input', (event) => {
                    const value = parseFloat(event.target.value);
                    state.impro.backingVolume = clampNumber(value, 0, 1);
                    state.improPrefs.backingVolume = state.impro.backingVolume;
                    saveImproPrefs(state.improPrefs);
                    updateImproBackingVolume();
                });
            }

            if (improUI.loopVolumeInput) {
                improUI.loopVolumeInput.value = state.impro.loopVolume;
                improUI.loopVolumeInput.addEventListener('input', (event) => {
                    const value = parseFloat(event.target.value);
                    state.impro.loopVolume = clampNumber(value, 0, 1);
                    state.improPrefs.loopVolume = state.impro.loopVolume;
                    saveImproPrefs(state.improPrefs);
                    updateImproLoopVolume();
                });
            }

            window.addEventListener('resize', layoutImproBlackKeys, { passive: true });
        }

        function enterImproMode() {
            applyImproSpace(state.improPrefs.space || state.impro.currentSpace || 'sun', { announce: false });
            ensureImproListening(true);
            startImproBacking();
            resumeImproLoops();
            appState.progress.improMeadow.sessions = (appState.progress.improMeadow.sessions || 0) + 1;
            saveAppState();
            if (state.audioContext) {
                setImproStatus('Spiel los. Die leuchtenden Tasten klingen immer gut zusammen.');
            } else {
                setImproStatus('Tippe auf ‚ÄûZuh√∂ren‚Äú, damit ich dich h√∂ren kann.');
            }
            updateImproListenButton();
        }

        function exitImproMode() {
            stopImproBacking();
            clearImproCall();
            clearImproTimeouts();
            pauseImproLoops();
            state.impro.pendingStart = false;
            state.impro.pendingLoopStart = false;
            if (state.impro.loopTimer) {
                clearTimeout(state.impro.loopTimer);
                state.impro.loopTimer = null;
            }
            if (state.impro.loopRecorder && state.impro.loopRecorder.state === 'recording') {
                try { state.impro.loopRecorder.stop(); } catch (_) {}
                state.impro.loopRecorder = null;
                state.impro.isLoopRecording = false;
                updateImproLoopStatus();
            }
            if (state.impro.visualTimeout) {
                clearTimeout(state.impro.visualTimeout);
                state.impro.visualTimeout = null;
            }
            if (improUI.pianoEl) {
                improUI.pianoEl.querySelectorAll('.impro-key.playing, .impro-key.contrast').forEach(k => {
                    k.classList.remove('playing', 'contrast');
                });
            }
            if (improUI.visualEl) {
                improUI.visualEl.classList.remove('active', 'contrast');
                improUI.visualEl.classList.add('soft');
            }
        }

        function applyImproSpace(spaceId, { announce }) {
            const space = improSpaces.find(s => s.id === spaceId) || improSpaces[0];
            state.impro.currentSpace = space.id;
            state.impro.currentScale = space.scale;
            state.improPrefs.space = space.id;
            saveImproPrefs(state.improPrefs);

            if (improUI.worldsEl) {
                improUI.worldsEl.querySelectorAll('.impro-world').forEach(card => {
                    card.classList.toggle('active', card.dataset.space === space.id);
                });
            }

            if (improUI.pianoEl) {
                improUI.pianoEl.style.setProperty('--impro-color', space.color);
                improUI.pianoEl.style.setProperty('--impro-glow', hexToRgba(space.color, 0.22));
            }

            updateImproAuraColor(space.color);
            updateImproKeyHighlights();

            if (state.currentModule === 'impro') {
                startImproBacking();
                resumeImproLoops();
            }

            if (announce) {
                setImproStatus(`${space.emoji} ${space.name}: spiel frei und sp√ºr, wie es sich anf√ºhlt.`);
            }
        }

        function renderImproPiano() {
            if (!improUI.pianoEl) return;
            improUI.pianoEl.innerHTML = '';
            const whiteWrap = document.createElement('div');
            whiteWrap.className = 'impro-white-keys';
            improUI.whiteContainer = whiteWrap;
            improUI.pianoEl.appendChild(whiteWrap);

            echoWhiteNotes.forEach((n) => {
                const key = document.createElement('div');
                key.className = 'impro-key white';
                key.dataset.note = n;
                key.setAttribute('aria-label', `Taste ${n}`);
                whiteWrap.appendChild(key);
            });

            const blackNotes = ["C#", "D#", "F#", "G#", "A#"];
            blackNotes.forEach((n) => {
                const key = document.createElement('div');
                key.className = 'impro-key black';
                key.dataset.note = n;
                key.setAttribute('aria-label', `Taste ${n}`);
                improUI.pianoEl.appendChild(key);
            });

            layoutImproBlackKeys();
            updateImproKeyHighlights();
        }

        function layoutImproBlackKeys() {
            if (!improUI.pianoEl || !improUI.whiteContainer) return;
            const pianoRect = improUI.pianoEl.getBoundingClientRect();
            const whiteKeys = Array.from(improUI.whiteContainer.querySelectorAll('.impro-key.white'));
            if (!pianoRect.width || whiteKeys.length < 7) return;

            const blackMap = {
                "C#": ["C", "D"],
                "D#": ["D", "E"],
                "F#": ["F", "G"],
                "G#": ["G", "A"],
                "A#": ["A", "B"]
            };

            const getWhiteByNote = (name) => whiteKeys[echoWhiteNotes.indexOf(name)];
            const firstWhiteRect = whiteKeys[0].getBoundingClientRect();
            const whiteW = firstWhiteRect.width;
            const blackW = Math.max(24, Math.floor(whiteW * 0.62));

            improUI.pianoEl.querySelectorAll('.impro-key.black').forEach((blackEl) => {
                const pair = blackMap[blackEl.dataset.note];
                if (!pair) return;
                const leftWhite = getWhiteByNote(pair[0]);
                const rightWhite = getWhiteByNote(pair[1]);
                if (!leftWhite || !rightWhite) return;
                const leftRect = leftWhite.getBoundingClientRect();
                const rightRect = rightWhite.getBoundingClientRect();
                const center = (leftRect.right + rightRect.left) / 2 - pianoRect.left;
                blackEl.style.width = `${blackW}px`;
                blackEl.style.left = `${Math.round(center - blackW / 2)}px`;
            });
        }

        function updateImproKeyHighlights() {
            if (!improUI.pianoEl) return;
            const scale = improScales[state.impro.currentScale] || improScales.pentatonic_major;
            improUI.pianoEl.querySelectorAll('.impro-key').forEach(key => {
                const pc = noteNameToPitchClass(key.dataset.note);
                const allowed = scale.includes(pc);
                key.classList.toggle('allowed', allowed);
            });
        }

        function setImproStatus(text) {
            if (!improUI.statusEl) return;
            improUI.statusEl.textContent = text;
        }

        function updateImproListenButton() {
            if (!improUI.listenBtn) return;
            if (!state.audioContext) {
                improUI.listenBtn.textContent = 'üé§ Zuh√∂ren';
                return;
            }
            improUI.listenBtn.textContent = state.isListening ? 'üéß Ich h√∂re' : 'üé§ Zuh√∂ren';
        }

        function updateImproAuraColor(hexColor) {
            if (!improUI.auraEl) return;
            const core = hexToRgba(hexColor, 0.78);
            const edge = hexToRgba(hexColor, 0.1);
            improUI.auraEl.style.background = `radial-gradient(circle, ${core}, ${edge})`;
            improUI.auraEl.style.boxShadow = `0 0 40px ${hexToRgba(hexColor, 0.35)}`;
        }

        function hexToRgba(hex, alpha) {
            const clean = hex.replace('#', '');
            if (clean.length !== 6) return `rgba(255, 255, 255, ${alpha})`;
            const r = parseInt(clean.slice(0, 2), 16);
            const g = parseInt(clean.slice(2, 4), 16);
            const b = parseInt(clean.slice(4, 6), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function initImproBackingTracks() {
            if (Object.keys(state.impro.backingTracks).length) return;
            improSpaces.forEach((space) => {
                const audio = new Audio();
                audio.loop = true;
                // Avoid downloading all backings upfront (WAV can be large). We'll lazy-load on first use.
                audio.preload = 'none';
                audio.volume = state.impro.backingVolume;

                audio._krCandidates = [
                    `assets/audio/backing/${space.id}.wav`,
                    `assets/audio/backing/${space.id}.mp3`,
                    `assets/audio/backing/${space.id}.m4a`
                ];
                audio._krCandidateIndex = 0;
                audio._krStarted = false;
                audio._krResolved = false;

                const tryCurrent = () => {
                    if (audio._krCandidateIndex >= audio._krCandidates.length) {
                        audio._krResolved = true;
                        state.impro.backingReady[space.id] = false;
                        return;
                    }
                    audio.src = audio._krCandidates[audio._krCandidateIndex];
                    audio.load();
                };

                audio.addEventListener('canplaythrough', () => {
                    if (audio._krResolved) return;
                    audio._krResolved = true;
                    state.impro.backingReady[space.id] = true;
                    if (state.currentModule === 'impro' && state.impro.currentSpace === space.id) {
                        startImproBacking();
                    }
                });
                audio.addEventListener('error', () => {
                    if (audio._krResolved) return;
                    audio._krCandidateIndex += 1;
                    tryCurrent();
                });

                state.impro.backingTracks[space.id] = audio;
                state.impro.backingReady[space.id] = false;
            });
        }

        function requestImproBackingLoad(spaceId) {
            const audio = state.impro.backingTracks[spaceId];
            if (!audio) return;
            if (audio._krStarted) return;
            audio._krStarted = true;
            audio._krCandidateIndex = 0;
            audio._krResolved = false;
            audio.src = audio._krCandidates[0];
            audio.load();
        }

        function playImproBackingTrack(spaceId) {
            requestImproBackingLoad(spaceId);
            const audio = state.impro.backingTracks[spaceId];
            if (!audio || !state.impro.backingReady[spaceId]) return false;
            if (state.impro.activeBackingId && state.impro.activeBackingId !== spaceId) {
                stopImproBackingAudio();
            }
            audio.volume = getImproBackingVolume();
            audio.currentTime = 0;
            audio.play().catch(() => {});
            state.impro.activeBackingId = spaceId;
            return true;
        }

        function stopImproBackingAudio() {
            if (!state.impro.activeBackingId) return;
            const audio = state.impro.backingTracks[state.impro.activeBackingId];
            if (audio) {
                audio.pause();
                audio.currentTime = 0;
            }
            state.impro.activeBackingId = null;
        }

        function getImproBackingVolume() {
            const base = state.impro.backingVolume || 0;
            const intensity = state.impro.backingIntensity || 0;
            const lift = 0.55 + intensity * 0.45;
            return clampNumber(base * lift, 0, 1);
        }

        function updateImproBackingVolume() {
            if (state.impro.activeBackingId) {
                const audio = state.impro.backingTracks[state.impro.activeBackingId];
                if (audio) audio.volume = getImproBackingVolume();
            }
        }

        function updateImproBackingIntensity() {
            const intensity = clampNumber((state.impro.bpm - 60) / 80, 0, 1);
            state.impro.backingIntensity = intensity;
            state.impro.backingGain = 0.008 + intensity * 0.01;
            updateImproBackingVolume();
        }

        function updateImproLoopVolume() {
            state.impro.loops.forEach((loop) => {
                if (loop.audio) loop.audio.volume = state.impro.loopVolume;
            });
        }

        function updateImproLoopStatus() {
            if (!improUI.loopStatusEl) return;
            if (typeof MediaRecorder === 'undefined') {
                improUI.loopStatusEl.textContent = 'Loop-Aufnahme ist in diesem Browser nicht verfuegbar.';
                updateImproLoopButton();
                return;
            }
            if (state.impro.isLoopRecording) {
                improUI.loopStatusEl.textContent = 'Loop nimmt auf...';
                updateImproLoopButton();
                return;
            }
            const count = state.impro.loops.length;
            improUI.loopStatusEl.textContent = count === 0
                ? 'Kein Loop aufgenommen.'
                : `${count} Loop${count === 1 ? '' : 's'} aktiv.`;
            updateImproLoopButton();
            if (improUI.loopClearBtn) {
                improUI.loopClearBtn.disabled = count === 0;
            }
        }

        function updateImproLoopButton() {
            if (!improUI.loopBtn) return;
            if (state.impro.isLoopRecording) {
                improUI.loopBtn.textContent = '‚è∫Ô∏è Aufnahme...';
                improUI.loopBtn.disabled = true;
            } else {
                improUI.loopBtn.textContent = 'üîÅ Loop aufnehmen';
                improUI.loopBtn.disabled = typeof MediaRecorder === 'undefined';
            }
        }

        function startImproLoopRecording() {
            if (state.impro.isLoopRecording) return;
            if (!state.mediaStream) {
                state.impro.pendingStart = true;
                state.impro.pendingLoopStart = true;
                document.getElementById('micModal').classList.add('active');
                if (improUI.loopStatusEl) {
                    improUI.loopStatusEl.textContent = 'Erst Mikrofon erlauben, dann nehmen wir den Loop auf.';
                }
                return;
            }
            if (typeof MediaRecorder === 'undefined') {
                if (improUI.loopStatusEl) {
                    improUI.loopStatusEl.textContent = 'Loop-Aufnahme ist hier nicht verfuegbar.';
                }
                return;
            }
            ensureImproListening(true);
            state.impro.isLoopRecording = true;
            updateImproLoopStatus();

            const recorder = new MediaRecorder(state.mediaStream);
            state.impro.loopRecorder = recorder;
            state.impro.loopChunks = [];

            recorder.ondataavailable = (event) => {
                if (event.data.size > 0) state.impro.loopChunks.push(event.data);
            };
            recorder.onstop = () => {
                const blob = new Blob(state.impro.loopChunks, { type: 'audio/webm' });
                state.impro.loopChunks = [];
                addImproLoop(blob);
                state.impro.isLoopRecording = false;
                state.impro.loopRecorder = null;
                updateImproLoopStatus();
            };

            recorder.start();
            if (state.impro.loopTimer) clearTimeout(state.impro.loopTimer);
            state.impro.loopTimer = setTimeout(() => {
                try { recorder.stop(); } catch (_) {}
                state.impro.loopTimer = null;
            }, state.impro.loopDurationMs);
        }

        function addImproLoop(blob) {
            const url = URL.createObjectURL(blob);
            const audio = new Audio(url);
            audio.loop = true;
            audio.volume = state.impro.loopVolume;
            audio.play().catch(() => {});
            const loop = { id: Date.now(), url, audio };
            state.impro.loops.push(loop);
            appState.progress.improMeadow.loopsRecorded = (appState.progress.improMeadow.loopsRecorded || 0) + 1;
            state.gardenProgress += 3;
            scheduleGardenSave();
            saveAppState();
            updateIslandView();
            updateImproLoopStatus();
        }

        function clearImproLoops() {
            state.impro.loops.forEach((loop) => {
                if (loop.audio) loop.audio.pause();
                if (loop.url) URL.revokeObjectURL(loop.url);
            });
            state.impro.loops = [];
            updateImproLoopStatus();
        }

        function pauseImproLoops() {
            state.impro.loops.forEach((loop) => {
                if (loop.audio) loop.audio.pause();
            });
        }

        function resumeImproLoops() {
            state.impro.loops.forEach((loop) => {
                if (loop.audio) loop.audio.play().catch(() => {});
            });
        }

        function ensureImproListening(userInitiated) {
            if (!state.audioContext) {
                if (userInitiated) state.impro.pendingStart = true;
                document.getElementById('micModal').classList.add('active');
                updateImproListenButton();
                return;
            }
            if (state.audioContext.state === 'suspended') {
                state.audioContext.resume().catch(() => {});
            }
            if (!state.isListening && state.analyser) {
                state.isListening = true;
                const micBtn = document.getElementById('micBtn');
                if (micBtn) micBtn.classList.add('listening');
                startNoteDetection();
            }
            updateImproListenButton();
        }

        function onImproStableNote(note) {
            if (state.currentModule !== 'impro') return;
            if (state.echo.isPlaying) return;
            if (!note || typeof note.frequency !== 'number') return;

            const scale = improScales[state.impro.currentScale] || improScales.pentatonic_major;
            const pc = noteNameToPitchClass(note.name);
            const isAllowed = scale.includes(pc);

            highlightImproKey(note.name, isAllowed ? 'playing' : 'contrast', 260);
            updateImproVisual(isAllowed);
            updateImproTempo();
            scheduleImproCall();

            if (isAllowed) {
                setImproStatus('Das klingt warm und rund. Spiel weiter.');
            } else {
                setImproStatus('Oh, ein spannender Kontrast.');
            }
        }

        function highlightImproKey(noteName, className, holdMs) {
            if (!improUI.pianoEl) return;
            const normalized = normalizeNoteName(noteName);
            const el = improUI.pianoEl.querySelector(`.impro-key[data-note="${normalized}"]`);
            if (!el) return;
            el.classList.add(className);
            const t = setTimeout(() => el.classList.remove(className), holdMs || 240);
            state.impro.timeouts.push(t);
        }

        function updateImproVisual(isAllowed) {
            if (!improUI.visualEl) return;
            if (state.impro.visualTimeout) {
                clearTimeout(state.impro.visualTimeout);
                state.impro.visualTimeout = null;
            }
            if (isAllowed) {
                improUI.visualEl.classList.add('active');
                improUI.visualEl.classList.remove('contrast');
                improUI.visualEl.classList.remove('soft');
                state.impro.visualTimeout = setTimeout(() => {
                    if (state.currentModule !== 'impro') return;
                    improUI.visualEl.classList.remove('active');
                    improUI.visualEl.classList.add('soft');
                }, 520);
            } else {
                improUI.visualEl.classList.add('contrast');
                improUI.visualEl.classList.remove('active');
                improUI.visualEl.classList.remove('soft');
                setTimeout(() => {
                    if (state.currentModule !== 'impro') return;
                    improUI.visualEl.classList.remove('contrast');
                    improUI.visualEl.classList.add('soft');
                }, 420);
            }
        }

        function updateImproTempo() {
            const now = performance.now();
            if (state.impro.lastNoteAt) {
                const delta = now - state.impro.lastNoteAt;
                if (delta > 120 && delta < 2000) {
                    state.impro.tempoSamples.push(delta);
                    if (state.impro.tempoSamples.length > 6) state.impro.tempoSamples.shift();
                    const avg = state.impro.tempoSamples.reduce((a, b) => a + b, 0) / state.impro.tempoSamples.length;
                    const bpm = clampNumber(Math.round(60000 / avg), 60, 140);
                    state.impro.bpm = bpm;
                    updateImproBackingIntensity();
                }
            }
            state.impro.lastNoteAt = now;
        }

        function scheduleImproCall() {
            if (!state.impro.responseEnabled) return;
            clearImproCall();
            state.impro.callTimeout = setTimeout(() => {
                if (state.currentModule !== 'impro') return;
                const now = performance.now();
                if (now - state.impro.lastNoteAt < 1500) return;
                playImproResponse(false);
            }, 1800);
        }

        function clearImproCall() {
            if (state.impro.callTimeout) {
                clearTimeout(state.impro.callTimeout);
                state.impro.callTimeout = null;
            }
        }

        function clearImproTimeouts() {
            if (!state.impro.timeouts.length) return;
            state.impro.timeouts.forEach(clearTimeout);
            state.impro.timeouts = [];
        }

        function playImproResponse(userInitiated) {
            if (!state.audioContext) return;
            if (!state.impro.responseEnabled) return;
            if (state.audioContext.state === 'suspended') {
                state.audioContext.resume().catch(() => {});
            }
            const now = performance.now();
            if (!userInitiated && now - state.impro.lastResponseAt < 2500) return;

            const scale = improScales[state.impro.currentScale] || improScales.pentatonic_major;
            const rootPc = scale[0];
            const otherPc = scale[Math.floor(Math.random() * scale.length)];
            const noteNames = [noteStrings[rootPc], noteStrings[otherPc]];

            const tempoMs = clampNumber(Math.round(60000 / state.impro.bpm), 380, 900);
            const startAt = state.audioContext.currentTime + 0.05;

            noteNames.forEach((noteName, i) => {
                const when = startAt + (i * tempoMs) / 1000;
                const duration = Math.max(0.18, tempoMs / 1000 * 0.8);
                playImproTone(noteName, when, duration, 0.06);
                const delay = Math.max(0, Math.round((when - startAt) * 1000));
                setTimeout(() => highlightImproKey(noteName, 'playing', 240), delay);
            });

            state.impro.lastResponseAt = performance.now();
        }

        function playImproTone(noteName, when, duration, volume) {
            const midi = noteNameToMidi(noteName, 4);
            const freq = midi ? midiToFrequency(midi) : null;
            if (!freq) return;
            const ctx = state.audioContext;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(freq, when);
            const peak = volume || 0.05;
            gain.gain.setValueAtTime(0.0001, when);
            gain.gain.linearRampToValueAtTime(peak, when + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.0001, when + duration);
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.start(when);
            osc.stop(when + duration + 0.03);
            state.echo.playNodes.push({ osc, gain });
        }

        function startImproBacking() {
            if (!state.audioContext) return;
            if (state.audioContext.state === 'suspended') {
                state.audioContext.resume().catch(() => {});
            }
            const played = playImproBackingTrack(state.impro.currentSpace);
            if (played) {
                state.impro.isBacking = false;
                if (state.impro.backingTimer) {
                    clearTimeout(state.impro.backingTimer);
                    state.impro.backingTimer = null;
                }
                return;
            }
            stopImproBackingAudio();
            if (state.impro.isBacking) return;
            state.impro.isBacking = true;
            runImproBacking();
        }

        function stopImproBacking() {
            state.impro.isBacking = false;
            if (state.impro.backingTimer) {
                clearTimeout(state.impro.backingTimer);
                state.impro.backingTimer = null;
            }
            stopImproBackingAudio();
        }

        function runImproBacking() {
            if (!state.impro.isBacking || state.currentModule !== 'impro') return;
            const tempoMs = clampNumber(Math.round(60000 / state.impro.bpm), 420, 900);
            const ctx = state.audioContext;
            const now = performance.now();
            const recentlyActive = now - state.impro.lastNoteAt < 5000;
            const when = ctx.currentTime + 0.02;

            if (recentlyActive) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(220, when);
                gain.gain.setValueAtTime(0.0001, when);
                gain.gain.linearRampToValueAtTime(state.impro.backingGain, when + 0.04);
                gain.gain.exponentialRampToValueAtTime(0.0001, when + 0.25);
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.start(when);
                osc.stop(when + 0.3);
                state.echo.playNodes.push({ osc, gain });
            }

            state.impro.backingTimer = setTimeout(runImproBacking, tempoMs);
        }

        // ==================== VISUALIZATION ====================
        function setupVisualization() {
            if (visualizerStarted) {
                if (typeof visualizerResize === 'function') visualizerResize();
                return;
            }
            visualizerStarted = true;

            const canvas = document.getElementById('visualizer');
            const ctx = canvas.getContext('2d');
            const particles = [];
            const barCount = 64;
            const maxParticles = reduceMotionQuery.matches ? 0 : 120;
            const frameInterval = 1000 / (reduceMotionQuery.matches ? 12 : VISUALIZATION_FPS);
            let dataArray = null;
            let bufferLength = 0;
            let lastFrameTime = 0;

            function resize() {
                const dpr = window.devicePixelRatio || 1;
                const rect = canvas.getBoundingClientRect();
                canvas.width = Math.max(1, Math.floor(rect.width * dpr));
                canvas.height = Math.max(1, Math.floor(rect.height * dpr));
            }
            visualizerResize = resize;
            resize();
            window.addEventListener('resize', resize, { passive: true });

            function getAnalyzerData() {
                if (!state.analyser) return null;
                if (!dataArray || bufferLength !== state.analyser.frequencyBinCount) {
                    bufferLength = state.analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);
                }
                state.analyser.getByteFrequencyData(dataArray);
                return dataArray;
            }

            function animate(now) {
                requestAnimationFrame(animate);
                if (document.hidden) return;
                if (now - lastFrameTime < frameInterval) return;
                lastFrameTime = now;

                ctx.fillStyle = 'rgba(26, 26, 46, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                if (state.isListening && state.analyser) {
                    const data = getAnalyzerData();
                    if (data) {
                        let sum = 0;
                        for (let i = 0; i < bufferLength; i++) {
                            sum += data[i];
                        }
                        const average = sum / bufferLength;
                        
                        if (average > 20 && particles.length < maxParticles) {
                            particles.push({
                                x: canvas.width / 2 + (Math.random() - 0.5) * 200,
                                y: canvas.height / 2,
                                vx: (Math.random() - 0.5) * 10,
                                vy: (Math.random() - 0.5) * 10 - 5,
                                radius: Math.random() * 20 + 5,
                                color: getWorldColor(),
                                life: 1
                            });
                        }

                        const barWidth = canvas.width / barCount;
                        const step = Math.max(1, Math.floor(bufferLength / barCount));
                        for (let i = 0; i < barCount; i++) {
                            const barHeight = data[i * step] * 1.5;
                            const hue = (i * 4) + (state.currentWorld ? getWorldHue() : 260);
                            ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.6)`;
                            ctx.fillRect(
                                i * barWidth,
                                canvas.height - barHeight,
                                barWidth - 2,
                                barHeight
                            );
                        }
                    }
                }

                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.1;
                    p.life -= 0.02;
                    
                    if (p.life <= 0) {
                        particles.splice(i, 1);
                        continue;
                    }

                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.radius * p.life, 0, Math.PI * 2);
                    ctx.fillStyle = p.color.replace('1)', `${p.life})`);
                    ctx.fill();
                }
            }
            requestAnimationFrame(animate);
        }

        function getWorldColor() {
            const colors = {
                mysterious: 'rgba(155, 93, 229, 1)',
                joyful: 'rgba(255, 217, 61, 1)',
                dreamy: 'rgba(77, 150, 255, 1)',
                exciting: 'rgba(255, 107, 107, 1)',
                calm: 'rgba(107, 203, 119, 1)'
            };
            return colors[state.currentWorld] || 'rgba(155, 93, 229, 1)';
        }

        function getWorldHue() {
            const hues = {
                mysterious: 270,
                joyful: 45,
                dreamy: 210,
                exciting: 0,
                calm: 140
            };
            return hues[state.currentWorld] || 260;
        }

        // ==================== NOTE DETECTION LOOP ====================
        function startNoteDetection() {
            if (!state.analyser) return;

            const bufferLength = state.analyser.fftSize;
            const buffer = new Float32Array(bufferLength);
            let lastDetectTime = 0;

            function detect(now) {
                if (!state.isListening) return;
                if (document.hidden) {
                    requestAnimationFrame(detect);
                    return;
                }
                if (now - lastDetectTime < NOTE_DETECT_MS) {
                    requestAnimationFrame(detect);
                    return;
                }
                lastDetectTime = now;
                
                state.analyser.getFloatTimeDomainData(buffer);
                const frequency = autoCorrelate(buffer, state.audioContext.sampleRate);
                
                if (frequency > 0) {
                    const note = frequencyToNote(frequency);
                    if (note) {
                        updateNoteDisplay(note);
                    }
                }
                
                requestAnimationFrame(detect);
            }
            requestAnimationFrame(detect);
        }

        // ==================== STABLE NOTE EVENTS ====================
        function feedPitchTracker(note, nowMs) {
            const pc = noteNameToPitchClass(note.name);
            if (pc < 0) return;

            const t = state.pitchTracker;
            if (t.candidatePitchClass === pc) {
                t.candidateFrames += 1;
            } else {
                t.candidatePitchClass = pc;
                t.candidateFrames = 1;
            }

            if (t.candidateFrames < t.stableFramesNeeded) return;
            if (t.lastEmittedPitchClass === pc) return;
            if (nowMs - t.lastEmittedAt < t.minMsBetweenNotes) return;

            t.lastEmittedPitchClass = pc;
            t.lastEmittedAt = nowMs;

            // Route to the currently active module(s).
            onEchoStableNote(note);
            onImproStableNote(note);
        }

        function updateNoteDisplay(note) {
            feedPitchTracker(note, performance.now());

            const noteEl = document.getElementById('currentNote');
            const historyEl = document.getElementById('noteHistory');

            if (noteEl) {
                noteEl.textContent = note.full;
                noteEl.style.color = getWorldColor();
            }

            // Add to history (avoid duplicates)
            if (state.noteHistory.length === 0 || 
                state.noteHistory[state.noteHistory.length - 1] !== note.full) {
                state.noteHistory.push(note.full);
                if (state.noteHistory.length > 8) state.noteHistory.shift();

                if (historyEl) {
                    historyEl.innerHTML = state.noteHistory
                        .map(n => `<span class="note-bubble">${n}</span>`)
                        .join('');
                }

                // Grow garden
                state.gardenProgress++;
                scheduleGardenSave();
            }
        }

        function scheduleGardenSave() {
            if (gardenSaveTimeout) return;
            gardenSaveTimeout = setTimeout(() => {
                syncGardenProgress();
                gardenSaveTimeout = null;
            }, GARDEN_SAVE_MS);
        }

        function syncGardenProgress() {
            localStorage.setItem('klangreise_garden', state.gardenProgress);
            appState.garden.growthPoints = state.gardenProgress;
            saveAppState();
            updateIslandView();
        }

        // ==================== RECORDING ====================
        function toggleRecording() {
            const btn = document.getElementById('recordBtn');
            
            if (!state.mediaRecorder) {
                alert('Aufnahmen werden in diesem Browser nicht unterst√ºtzt.');
                return;
            }
            
            if (!state.isRecording) {
                state.recordedChunks = [];
                state.recordingStart = performance.now();
                state.recordingStop = null;
                state.mediaRecorder.start();
                state.isRecording = true;
                btn.classList.add('recording');
                btn.textContent = '‚èπÔ∏è';
            } else {
                state.recordingStop = performance.now();
                state.mediaRecorder.stop();
                state.isRecording = false;
                btn.classList.remove('recording');
                btn.textContent = '‚è∫Ô∏è';
            }
        }

        function saveRecording() {
            const blob = new Blob(state.recordedChunks, { type: 'audio/webm' });
            const url = URL.createObjectURL(blob);
            const durationMs = (state.recordingStart && state.recordingStop)
                ? (state.recordingStop - state.recordingStart)
                : null;
            const duration = durationMs
                ? Math.max(1, Math.round(durationMs / 1000))
                : Math.floor(state.recordedChunks.length / 2);
            
            const recording = {
                id: Date.now(),
                url: url,
                date: new Date().toLocaleDateString('de-DE'),
                time: new Date().toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }),
                emoji: ['üéµ', 'üé∂', 'üéπ', '‚ú®', 'üåü', 'üí´', 'üéº'][Math.floor(Math.random() * 7)],
                world: state.currentWorld,
                duration: duration
            };
            
            state.recordings.unshift(recording);
            localStorage.setItem('klangreise_recordings', JSON.stringify(
                state.recordings.map(r => ({ ...r, url: null })) // Don't store blob URLs
            ));
            state.recordingStart = null;
            state.recordingStop = null;
            
            updateDiaryView();
            
            // Show feedback
            alert('üéâ Toll gemacht! Deine Aufnahme wurde im Klangtagebuch gespeichert!');
        }

        function playRecording(url) {
            if (!url) return;
            if (activeAudio) {
                activeAudio.pause();
                activeAudio.currentTime = 0;
            }
            const audio = new Audio(url);
            activeAudio = audio;
            audio.play();
            audio.addEventListener('ended', () => {
                if (activeAudio === audio) activeAudio = null;
            });
        }

        // ==================== UI UPDATES ====================
        function updateDiaryView() {
            const container = document.getElementById('diaryEntries');
            const totalEl = document.getElementById('totalRecordings');
            const minutesEl = document.getElementById('totalMinutes');
            
            totalEl.textContent = state.recordings.length;
            minutesEl.textContent = Math.floor(state.recordings.reduce((a, r) => a + (r.duration || 0), 0) / 60);
            
            if (state.recordings.length === 0) {
                container.innerHTML = `
                    <div class="empty-diary">
                        <div class="empty-diary-icon">üéµ</div>
                        <p>Noch keine Aufnahmen ‚Äì deine erste Klanggeschichte wartet auf dich!</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = state.recordings.map(r => `
                <div class="diary-entry">
                    <div class="entry-emoji">${r.emoji}</div>
                    <div class="entry-info">
                        <div class="entry-date">${r.date} um ${r.time}</div>
                        <div class="entry-title">${r.world ? 'Klangwelt: ' + r.world : 'Freies Spielen'}</div>
                        <div class="entry-duration">${r.duration || '?'} Sekunden</div>
                    </div>
                    ${r.url ? `<button class="entry-play" onclick="playRecording('${r.url}')">‚ñ∂Ô∏è</button>` : ''}
                </div>
            `).join('');
        }

        function updateGardenView() {
            const garden = document.getElementById('gardenVisual');
            const progress = state.gardenProgress;
            
            // Add plants based on progress
            const plants = ['üå±', 'üåø', 'üå∏', 'üå∫', 'üåª', 'üå∑', 'üåπ', 'ü™ª', 'üåº', 'üíê'];
            const trees = ['üå≤', 'üå≥', 'üå¥'];
            
            let plantsHTML = '';
            const numPlants = Math.min(Math.floor(progress / 10), 15);
            
            for (let i = 0; i < numPlants; i++) {
                const plant = progress > 100 && i < 3 ? trees[i % 3] : plants[i % plants.length];
                const left = 10 + (i * 6) + (Math.random() * 3);
                const delay = i * 0.2;
                plantsHTML += `<div class="plant" style="left: ${left}%; animation-delay: ${delay}s;">${plant}</div>`;
            }
            
            const message = progress < 10 
                ? 'Spiele und entdecke, um deinen Garten wachsen zu lassen!'
                : progress < 50 
                    ? 'Dein Garten beginnt zu wachsen! üå±'
                    : progress < 100 
                        ? 'Wunderbar! So viele sch√∂ne Pflanzen! üå∏'
                        : 'Wow! Dein Garten ist ein Paradies! üå≥‚ú®';
            
            garden.innerHTML = `
                <div class="garden-message">${message}</div>
                ${plantsHTML}
                <div class="garden-ground"></div>
            `;
        }

        // ==================== EVENT HANDLERS ====================
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                openScreen(tab.dataset.screen);
            });
        });

        document.getElementById('startBtn').addEventListener('click', () => {
            appState.user.introSeen = true;
            saveAppState();
            openScreen('island');
        });

        document.querySelectorAll('.island-landmark').forEach((landmark) => {
            const disabled = landmark.dataset.disabled === 'true';
            if (disabled) {
                landmark.classList.add('disabled');
                return;
            }
            landmark.addEventListener('click', () => {
                const screen = landmark.dataset.screen || 'play';
                const module = landmark.dataset.module || null;
                if (module) {
                    openModule(module);
                } else {
                    openScreen(screen);
                }
            });
        });

        const islandGardenBtn = document.getElementById('islandGarden');
        if (islandGardenBtn) {
            islandGardenBtn.addEventListener('click', () => openScreen('garden'));
        }

        const compassBtn = document.getElementById('compassBtn');
        if (compassBtn) {
            compassBtn.addEventListener('click', () => openScreen('island'));
        }

        document.getElementById('allowMicBtn').addEventListener('click', async () => {
            const success = await setupAudio();
            if (success) {
                document.getElementById('micModal').classList.remove('active');
                state.isListening = true;
                document.getElementById('micBtn').classList.add('listening');
                startNoteDetection();
                setupVisualization();
                updateEchoControls();
                updateImproListenButton();

                if (state.currentModule === 'echo' && state.echo.pendingStart) {
                    state.echo.pendingStart = false;
                    startEchoRound({ replay: false });
                }
                if (state.currentModule === 'impro' && state.impro.pendingStart) {
                    state.impro.pendingStart = false;
                    enterImproMode();
                    if (state.impro.pendingLoopStart) {
                        state.impro.pendingLoopStart = false;
                        startImproLoopRecording();
                    }
                }
            }
        });

        document.getElementById('micBtn').addEventListener('click', async () => {
            if (!state.audioContext) {
                document.getElementById('micModal').classList.add('active');
                return;
            }
            
            state.isListening = !state.isListening;
            document.getElementById('micBtn').classList.toggle('listening', state.isListening);
            
            if (state.isListening) {
                startNoteDetection();
            }
            updateEchoControls();
            updateImproListenButton();
        });

        document.getElementById('recordBtn').addEventListener('click', () => {
            if (!state.audioContext) {
                alert('Bitte aktiviere zuerst das Mikrofon! üé§');
                return;
            }
            toggleRecording();
        });

        document.getElementById('saveBtn').addEventListener('click', () => {
            alert('üíæ Bald kannst du hier kleine Klangnotizen speichern!');
        });

        document.getElementById('newPromptBtn').addEventListener('click', () => {
            const prompt = prompts[Math.floor(Math.random() * prompts.length)];
            document.getElementById('dailyPrompt').textContent = prompt;
        });

        document.querySelectorAll('.world-card').forEach(card => {
            card.addEventListener('click', () => {
                document.querySelectorAll('.world-card').forEach(c => c.classList.remove('active'));
                card.classList.add('active');
                state.currentWorld = card.dataset.world;
                document.getElementById('moodLabel').textContent = card.querySelector('.world-name').textContent;
                document.querySelector('[data-screen="play"]').click();
            });
        });

        // ==================== BACKGROUND PARTICLES ====================
        function createBackgroundParticles() {
            if (reduceMotionQuery.matches) return;
            const container = document.getElementById('particles');
            const colors = ['#9b5de5', '#4d96ff', '#6bcb77', '#ffd93d', '#ff6b6b'];
            const fragment = document.createDocumentFragment();
            
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.width = `${Math.random() * 100 + 20}px`;
                particle.style.height = particle.style.width;
                particle.style.left = `${Math.random() * 100}%`;
                particle.style.top = `${Math.random() * 100}%`;
                particle.style.background = colors[Math.floor(Math.random() * colors.length)];
                particle.style.animationDelay = `${Math.random() * 20}s`;
                particle.style.animationDuration = `${Math.random() * 20 + 15}s`;
                fragment.appendChild(particle);
            }
            container.appendChild(fragment);
        }

        // ==================== INIT ====================
        window.addEventListener('beforeunload', () => {
            if (gardenSaveTimeout) {
                syncGardenProgress();
                gardenSaveTimeout = null;
            }
        });

        createBackgroundParticles();
        setupModuleTabs();
        initEchoGame();
        initImproPlayground();
        applyIslandTheme();
        updateIslandView();
        openScreen('island');
        updateDiaryView();
        updateImproListenButton();
        
        // Random prompt on load
        document.getElementById('dailyPrompt').textContent = 
            prompts[Math.floor(Math.random() * prompts.length)];
    </script>
</body>
</html>
